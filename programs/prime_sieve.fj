// This fj program prints all the prime numbers (as decimal numbers) up to a number n (given by input).

hw = w/4
PRIMES_MEMORY_START = (1 << (w-2))   // 1/4 of the memory
PRIMES_MEMORY_LENGTH = (1 << (w-1))  // 1/2 of the memory
MAX_PRIMES = PRIMES_MEMORY_LENGTH / dw
stl.startup_and_init_all


// in order to "mark", we'll use a different primes_ptr. maybe we need one for read, and one for write.
//set_primes_ptr temp1
//hex.xor_to_ptr primes_ptr, temp1
//set_primes_ptr temp2
//hex.xor_to_ptr primes_ptr, temp2

// The main program

  input_max_prime n
  handle_small_n n, end
//  hex.set hw, primes_ptr, PRIMES_MEMORY_START + 5 * dw

prime_loop_if:
  hex.cmp hw, p, n, prime_loop, prime_loop, end
prime_loop:
  if1_ptr primes_ptr, next_prime
  print_int hw, p  // TODO save ton of times by declaring p "dec", with dec.vec, dec.set, dec.add and dec.print.

  // TODO mark every p*(p+i) as not prime (stop when reached > n)
next_prime:
  set_next_prime p, primes_ptr, is_add_4, prime_loop_if


end:
  stl.loop


// Variables:

n: hex.vec hw
p: hex.vec hw, 5
primes_ptr: hex.vec hw, PRIMES_MEMORY_START + 5 * dw

temp1: hex.vec hw, 37
//temp2: hex.vec hw, 41

is_add_4: bit.bit 0  // if 0: add 2, else: add 4.

// Segments:

segment PRIMES_MEMORY_START
    reserve PRIMES_MEMORY_LENGTH


// Macro definitions:


// if n < 2, print nothing and exit. if n == 2 print 2 and exit. else, print 2,3 and continue.
def handle_small_n n, finish_address @ equals_2, print_2_3_then_start, two, continue_address {
    hex.cmp hw, n, two, finish_address, equals_2, print_2_3_then_start
  equals_2:
    stl.output "2\n"
    ;finish_address
  print_2_3_then_start:
    stl.output "2\n3\n"
    ;continue_address

  two: hex.vec hw, 2

  continue_address:
}


// Time Complexity:  19@+31
//   p += 2/4 (depends on the is_add_4 flag). primes_ptr += 2/4 * dw. flip the flag, and jump to continue_address.
def set_next_prime p, primes_ptr, is_add_4, continue_address @ p_add_2, p_add_4 {
    bit.if is_add_4, p_add_2, p_add_4
  p_add_2:
    hex.add_constant hw, primes_ptr, 2 * dw
    hex.add_constant hw, p, 2
    is_add_4+dbit; continue_address
  p_add_4:
    hex.add_constant hw, primes_ptr, 4 * dw
    hex.add_constant hw, p, 4
    is_add_4+dbit; continue_address
}


// print hex[:n] as a decimal integer.
def print_int n, hex @ bit, end{
    stl.hex2bit n, bit, hex
    bit.print_dec_int 4*n, bit
    stl.output '\n'
    ;end

  bit: bit.vec 4*n

  end:
}


// if *hex_ptr != 0 goto l1.
def if1_ptr hex_ptr, l1 @ l0 {
    if_ptr hex_ptr, l0, l1
  l0:
}


// if *hex_ptr == 0 goto l0, else goto l1.
def if_ptr hex_ptr, l0, l1 @ ptr_value {
    hex.zero ptr_value
    hex.xor_from_ptr ptr_value, hex_ptr
    hex.if ptr_value, l0, l1

  ptr_value: hex.hex
}


// primes_ptr = PRIMES_MEMORY_START + p*dw
def set_primes_ptr p @ p_offset, end < primes_ptr {
    hex.set hw, primes_ptr, PRIMES_MEMORY_START
    hex.mov hw, p_offset, p
    shl_hex hw, p_offset, #w
    hex.add hw, primes_ptr, p_offset
    ;end

  p_offset: hex.vec hw

  end:
}


// hex[:n] <<= shift
def shl_hex n, hex, shift {
    rep(shift/4, i) hex.shl_hex n, hex
    rep(shift%4, i) hex.shl_bit n, hex
}


// n = input_decimal_number(). check that n is smaller than MAX_PRIMES.
def input_max_prime n @ bit_n, max_n, raise_more_than_max_primes, end {
    stl.output "Search primes up to: "
    input_decimal_number w, bit_n
    stl.bit2hex w, n, bit_n

    hex.cmp hw, n, max_n, end, raise_more_than_max_primes, raise_more_than_max_primes

  bit_n: bit.vec w
  max_n: hex.vec hw, MAX_PRIMES

  raise_more_than_max_primes:
    raise_error "The input number should be less than ((1 << (w-2)) / w).\n  For w=16 it's 1024.\n  For w=32 it's ~33M.\n  For w=64 it's ~7e16."

    end:
}


// bit[:n] = input_ascii_as_decimal. expects \n at finish, and no other characters other then '0'-'9'.
//   example: for input "1234\n" does bit[:n]=1234.
def input_decimal_number n, bit \
        @ input_decimal_digit, end, dec_digit, is_error, ascii, i, i_start, \
        error_handler, newline, raise_not_number_error {
    bit.zero n, bit
    bit.mov #n, i, i_start

  input_decimal_digit:
    bit.if0 #n, i, end
    bit.input ascii
    bit.ascii2dec is_error, dec_digit, ascii
    bit.if1 is_error, error_handler
    bit.mul10 n, bit
    bit.add n, bit, dec_digit
    bit.dec #n, i
    ;input_decimal_digit

  dec_digit: bit.vec n
  newline: bit.vec 8, '\n'
  is_error: bit.bit
  ascii: bit.vec 8
  i: bit.vec #n
  i_start: bit.vec #n, n

  error_handler:
    bit.cmp 8, ascii, newline, raise_not_number_error, end, raise_not_number_error
  raise_not_number_error:
    raise_error "Bad number given. The number should be positive, only digits, and end with a new-line."

  end:
}


// pretty way of printing an error and then exiting.
def raise_error msg {
    stl.output "\n\nError:\n"
    stl.output msg
    stl.output "\nExiting program.\n"
    stl.loop
}
