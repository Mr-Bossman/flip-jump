// ---------- Jump:


ns bit {
    ns pointers {
        // Space Complexity: 3w+2
        //   Inits the global opcodes and pointer-copies required for the pointers macros.
        //
        // @output-param to_flip:  address of opcode that holds a flipping address in its first word. jumping into it will flip wanted bit.
        // @output-param to_flip_var:  the bit-vector (pointer) that also holds the flipping address.
        // @output-param to_jump:  address of opcode that holds a jumping address in its second word. jumping into it will jump to the wanted address.
        // @output-param to_jump_var:  the bit-vector (pointer) that also holds the jumping address.
        def ptr_init > to_flip, to_jump, to_flip_var, to_jump_var {
          to_flip:
            0;0
          to_jump:
            ;0

          to_flip_var:
            bit.vec w, 0
          to_jump_var:
            bit.vec w, 0
        }

        // Complexity: 2n@
        //   Sets both to_jump and to_jump_var to point to the given pointer.
        //   (  to_jump{_var} = ptr  )
        // ptr is a bit[:w] that holds an address.
        def set_jump_pointer ptr < .to_jump, .to_jump_var {
            ..address_and_variable_xor w, .to_jump+w, .to_jump_var, .to_jump_var
            ..address_and_variable_xor w, .to_jump+w, .to_jump_var, ptr
        }


        // Complexity: 2n@
        //   Sets both to_flip and to_flip_var to point to the given pointer.
        //   (  to_flip{_var} = ptr  )
        // ptr is a bit[:w] that holds an address.
        def set_flip_pointer ptr < .to_flip, .to_flip_var {
            ..address_and_variable_xor w, .to_flip, .to_flip_var, .to_flip_var
            ..address_and_variable_xor w, .to_flip, .to_flip_var, ptr
        }
    }
}


ns bit {
    // Complexity: 2w@ + 2
    //   like:  ;*ptr
    //   Jump to the address the pointer points to.
    //   ( to_jump{_var} = ptr.  ==>  ;to_jump )
    // ptr is a bit[:w] that holds an address.
    def ptr_jump ptr < bit.pointers.to_jump {
        .pointers.set_jump_pointer ptr
        ;bit.pointers.to_jump
    }
}



// ---------- Flip:


ns bit {
    // Complexity: 2w@ + @
    //   like:  *ptr;
    //   Flip the address the pointer points to.
    //   ( to_flip{_var} = ptr.  ==>  ;to_flip )
    // ptr is a bit[:w] that holds an address.
    def ptr_flip ptr @ cleanup < bit.pointers.to_flip {
        wflip bit.pointers.to_flip+w, cleanup

        .pointers.set_flip_pointer ptr
        ;bit.pointers.to_flip

        pad 4
      cleanup:
        wflip bit.pointers.to_flip+w, cleanup
    }


    // Complexity 2w@ + 2@
    // The stl.comp_flip_if executes in ~##w, which should be much less than @/2 operations.
    //   like:  (*ptr)+dbit;
    //   Flip the address dbit-ahead of what the pointer points to.
    // ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def ptr_flip_dbit ptr {
        rep(#dbit, i) stl.comp_flip_if ptr+dbit+i*dw, (dbit>>i)&1
        .ptr_flip ptr
        rep(#dbit, i) stl.comp_flip_if ptr+dbit+i*dw, (dbit>>i)&1
    }

    // Complexity 2w@ + 2@+2
    //   like:  bit.xor *ptr, bit
    // ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def xor_to_ptr ptr, bit @ end {
        .if0 bit, end
        .ptr_flip_dbit ptr
      end:
    }


    // Complexity 3w@  (actually a bit smaller, 2w@+3w + (@-2)^2)
    //   like:  wflip *ptr, value
    // ptr is a bit[:w] that holds an address, which we assume is w-aligned.
    def ptr_wflip ptr, value {
        .pointers.set_flip_pointer ptr
        rep(w, i) .pointers.advance_by_one_and_flip__ptr_wflip (#(i^((i+1)%w))), (value>>i)&1
    }
    ns pointers {
        // Advances *to_flip by 1 (which takes n flips, from bit0 to bit1, bit2,...).
        // If do_flip (value) isn't 0 - than make a flip, like:  to_flip;advance.
        def advance_by_one_and_flip__ptr_wflip n, do_flip @ cleanup, advance < bit.pointers.to_flip {
            stl.comp_if0 do_flip, advance
            wflip bit.pointers.to_flip+w, cleanup, bit.pointers.to_flip
          cleanup:
            wflip bit.pointers.to_flip+w, cleanup, advance

            pad 4
          advance:
            rep(n, i) bit.exact_not bit.pointers.to_flip+i
        }
    }

    // Complexity 3w@  (actually a bit smaller, 2w@+3w+2 + (@-2)^2)
    //   like:  wflip (*ptr)+w, value
    // ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def ptr_wflip_2nd_word ptr, value {
        .not ptr + dw*(#w-1)
        .ptr_wflip ptr, value
        .not ptr + dw*(#w-1)
    }
}



// ---------- Xor


ns bit {
    // Complexity 7w@ (actually a bit smaller, 6w@+6w+8 + 2(@-2)^2)
    //   like:  bit.xor dst, *ptr
    // dst is a bit. ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def xor_from_ptr dst, ptr {
        .exact_xor_from_ptr dst+dbit, ptr
    }

    // Complexity 7w@ (actually a bit smaller, 6w@+6w+8 + 2(@-2)^2)
    //   like:  bit.exact_xor dst, *ptr
    // dst is a bit-address. ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def exact_xor_from_ptr dst, ptr @ base_jump_label, cleanup {
        .ptr_wflip_2nd_word ptr, base_jump_label

        .ptr_jump ptr
        pad 2
      base_jump_label:
        ;cleanup
        dst;

      cleanup:
        .ptr_wflip_2nd_word ptr, base_jump_label

    }
}



// ---------- Stack


ns bit {
    // Space Complexity: n+w
    //   Initializes a stack of size n (maximal capacity of n bits / return-addresses).
    // n is the size of the stack.
    def stack_init n {
        stl.pointers.stack_init n
    }

    ns pointers {
        // Space Complexity: n+w
        //   Initializes a stack of size n (maximal capacity of n bits / return-addresses).
        // n is the size of the stack.
        // @output-param sp: the stack pointer. sp always points to the last pushed value (at start - to stack[-1])
        // @output-param stack: the global stack.
        def stack_init n > sp, stack {
          sp:
            bit.vec w, .stack-dw
          stack:
            bit.vec n, 0
        }
    }

    //  Time Complexity: n(2@)
    // Space Complexity: n(2@+24)
    // Unsafe if dst is stl.pointers.sp.
    //   dst[:n] = sp
    def get_sp dst < stl.pointers.sp {
        .mov w, dst, stl.pointers.sp
    }


    //  Time Complexity: 1.067@         // (16/15 * @)
    // Space Complexity: w(1.5@+13)     // actually (w-#w)(1.5@+13)
    //   ptr[:n] += 2w
    def inc_ptr ptr {
        .inc w-#w, ptr+#w*dw
    }

    //  Time Complexity: 1.067@         // (16/15 * @)
    // Space Complexity: w(1.5@+13)     // actually (w-#w)(1.5@+13)
    //   ptr[:n] -= 2w
    def dec_ptr ptr {
        .dec w-#w, ptr+#w*dw
    }


    //  Time Complexity: 4w@  (actually a bit smaller)
    // Space Complexity: 5w@  (actually a bit smaller)
    //   Like:  stack[++sp] = return_address
    //   Pushes the given return_address to the next cell in the stack (assumes it's zero). Increments sp.
    // return_address is a fj-op address, so we assume is dw-aligned.
    def push_ret_address return_address < stl.pointers.sp {
        .inc_ptr stl.pointers.sp
        .ptr_wflip_2nd_word stl.pointers.sp, return_address
    }

    //  Time Complexity: 4w@  (actually a bit smaller)
    // Space Complexity: 5w@  (actually a bit smaller)
    //   Like:  stack[sp--] = 0
    //   Pops the given return_address from the current cell in the stack (assumes it has the value of the return_address). Decrements sp.
    // return_address is a fj-op address, so we assume is dw-aligned.
    def pop_ret_address return_address < stl.pointers.sp {
        .ptr_wflip_2nd_word stl.pointers.sp, return_address
        .dec_ptr stl.pointers.sp
    }


    //  Time Complexity: 2w@ + 3@+2
    // Space Complexity: w(3.5@+13)
    //   Like:  stack[++sp] = bit
    //   Pushes the given bit to the next cell in the stack (assumes it's zero). Increments sp.
    def push bit < stl.pointers.sp {
        .inc_ptr stl.pointers.sp
        .xor_to_ptr stl.pointers.sp, bit
    }

    //  Time Complexity: 2w@ + 3@+2
    // Space Complexity: w(3.5@+13)
    //   Like:  stack[sp--] = 0
    //   Pops the given bit from the current cell in the stack (assumes it has the value of bit). Decrements sp.
    def pop bit < stl.pointers.sp {
        .xor_to_ptr stl.pointers.sp, bit
        .dec_ptr stl.pointers.sp
    }


    //  Time Complexity: w(10@+10)  (actually a bit smaller, 8w@ + 10w+9 + 2(@-2)^2)
    // Space Complexity: w(11@+20)  (actually a bit smaller, w(9.5@+19) + 2(@-2)^2 + @-1)
    //   Like:  bit = stack[sp]
    //          stack[sp--] = 0
    //   Pops the current stack cell into the the given bit. Decrements sp.
    // bit is only an output parameter
    def pop_res bit < stl.pointers.sp {
        .zero bit
        .xor_from_ptr bit, stl.pointers.sp
        .pop bit
    }
}
