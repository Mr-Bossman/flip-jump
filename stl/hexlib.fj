// Every line is (16) bananas!
// Implementation of hexadecimal-variables operations, and vectors of it

// should be assembled with the runlib.fj file
// This file is independent of the bit-width, and uses the consts defined at runlib.fj

// Everything after // is ignored, and every whitespace is ignored (besides new line)
// An opcode is:  F;J  F;  ;J  or just  ;  (no F => F=0;  no J => J=next)

// Complexity note: phi is log2 of the total number of fj operations, counting wflips as one op.
// so 2 wflips with value=label (while label is padded with 2^n) causes phi-n space/time complexity

// Space complexity might not be exact


// ---------- Memory Variables:
// Size Complexity: 1


def hex val {
    ;(val > 0xf ? 0xf : (val < 0 ? 0 : val)) * dw
}

def hex {
    hex 0
}


ns hex {
    def vec n, value {
        rep(n, i) hex (value>>(4*i))&0xf
    }

    def vec n {
        rep(n, i) hex
    }
}


// ---------- Logical Macros:


ns hex {

    //  Time Complexity: phi
    // Space Complexity: phi+27
    def xor dst, src {
        .exact_xor dst+dbit+3, dst+dbit+2, dst+dbit+1, dst+dbit+0, src
    }

    //  Time Complexity: n*phi
    // Space Complexity: n*(phi+26)
    def xor n, dst, src {
        rep (n, i) .xor dst+i*dw, src+i*dw
    }


    //  Time Complexity: phi
    // Space Complexity: phi+27
    def exact_xor d3, d2, d1, d0, src @ switch, end {
        wflip src+w, switch, src
        pad 16
      switch:
          ;end          //  0
        d0;end          //  1
        d1;end          //  2
        d1;switch+1*dw  //  3
        d2;end          //  4
        d2;switch+1*dw  //  5
        d2;switch+2*dw  //  6
        d2;switch+3*dw  //  7
        d3;end          //  8
        d3;switch+1*dw  //  9
        d3;switch+2*dw  // 10
        d3;switch+3*dw  // 11
        d3;switch+4*dw  // 12
        d3;switch+5*dw  // 13
        d3;switch+6*dw  // 14
        d3;switch+7*dw  // 15
      end:
        wflip src+w, switch
    }

    //  Time Complexity: phi+4
    // Space Complexity: phi+42
    def xor_zero dst, src {
        .double_xor dst, src, src
    }

    //  Time Complexity: n(phi+4)
    // Space Complexity: n(phi+42)
    def xor_zero n, dst, src {
        rep (n, i) .xor_zero dst+i*dw, src+i*dw
    }

    //  Time Complexity: phi+4
    // Space Complexity: phi+42
    def double_xor dst1, dst2, src {
        .double_exact_xor dst1+dbit+3, dst1+dbit+2, dst1+dbit+1, dst1+dbit+0, dst2+dbit+3, dst2+dbit+2, dst2+dbit+1, dst2+dbit+0, src
    }

    //  Time Complexity: phi+4
    // Space Complexity: phi+42
    def double_exact_xor t3, t2, t1, t0, d3, d2, d1, d0, src @ switch, second_flip, end {
        wflip src+w, switch, src
        pad 16
      switch:
          ;end                  //  0
        d0;second_flip+ 0*dw    //  1
        d1;second_flip+ 1*dw    //  2
        d1;second_flip+ 2*dw    //  3
        d2;second_flip+ 3*dw    //  4
        d2;second_flip+ 4*dw    //  5
        d2;second_flip+ 5*dw    //  6
        d2;second_flip+ 6*dw    //  7
        d3;second_flip+ 7*dw    //  8
        d3;second_flip+ 8*dw    //  9
        d3;second_flip+ 9*dw    // 10
        d3;second_flip+10*dw    // 11
        d3;second_flip+11*dw    // 12
        d3;second_flip+12*dw    // 13
        d3;second_flip+13*dw    // 14
        d3;second_flip+14*dw    // 15

        d3;end          //  8
        d3;switch+1*dw  //  9
        d3;switch+2*dw  // 10
        d3;switch+3*dw  // 11
        d3;switch+4*dw  // 12
        d3;switch+5*dw  // 13
        d3;switch+6*dw  // 14
        d3;switch+7*dw  // 15
      second_flip:
        t0;end          //  1
        t1;end          //  2
        t1;switch+1*dw  //  3
        t2;end          //  4
        t2;switch+1*dw  //  5
        t2;switch+2*dw  //  6
        t2;switch+3*dw  //  7
        t3;end          //  8
        t3;switch+1*dw  //  9
        t3;switch+2*dw  // 10
        t3;switch+3*dw  // 11
        t3;switch+4*dw  // 12
        t3;switch+5*dw  // 13
        t3;switch+6*dw  // 14
        t3;switch+7*dw  // 15
      end:
        wflip src+w, switch
    }


    // Complexity: 4
    def not hex {
        hex+dbit+0;
        hex+dbit+1;
        hex+dbit+2;
        hex+dbit+3;
    }

    // Complexity: 4n
    def not n, hex {
        rep(n, i) .not hex+i*dw
    }


    //  Time Complexity: phi
    // Space Complexity: 1.5phi+28
    def inc1 hex, carry0, carry1 @ switch, end {
        wflip hex+w, switch, hex
        pad 16
      switch:
        hex+dbit+0;end          //  0
        hex+dbit+1;switch+0*dw  //  1
        hex+dbit+0;end          //  2
        hex+dbit+2;switch+1*dw  //  3
        hex+dbit+0;end          //  4
        hex+dbit+1;switch+0*dw  //  5
        hex+dbit+0;end          //  6
        hex+dbit+3;switch+3*dw  //  7
        hex+dbit+0;end          //  8
        hex+dbit+1;switch+0*dw  //  9
        hex+dbit+0;end          // 10
        hex+dbit+2;switch+1*dw  // 11
        hex+dbit+0;end          // 12
        hex+dbit+1;switch+0*dw  // 13
        hex+dbit+0;end          // 14
        hex+dbit+3;             // 15
        hex+dbit+2;
        hex+dbit+1;
        hex+dbit+0;
        wflip hex+w, switch, carry1
      end:
        wflip hex+w, switch, carry0
    }

    //  Time Complexity: n*phi
    // Space Complexity: n(1.5phi+23)
    def inc n, hex @ end {
        rep(n, i) .inc.step hex+i*dw, end
      end:
    }
    ns inc {
        def step hex, end @ next {
            ..inc1 hex, end, next
          next:
        }
    }


    //  Time Complexity: phi
    // Space Complexity: 1.5phi+28
    def dec1 hex, borrow0, borrow1 @ switch, borrow, end {
        wflip hex+w, switch, hex
        pad 16
      switch:
        hex+dbit+3;borrow       //  0
        hex+dbit+0;end          //  1
        hex+dbit+1;switch+1*dw  //  2
        hex+dbit+0;end          //  3
        hex+dbit+2;switch+2*dw  //  4
        hex+dbit+0;end          //  5
        hex+dbit+1;switch+1*dw  //  6
        hex+dbit+0;end          //  7
        hex+dbit+3;switch+4*dw  //  8
        hex+dbit+0;end          //  9
        hex+dbit+1;switch+1*dw  // 10
        hex+dbit+0;end          // 11
        hex+dbit+2;switch+2*dw  // 12
        hex+dbit+0;end          // 13
        hex+dbit+1;switch+1*dw  // 14
        hex+dbit+0;end          // 15
      borrow:
        hex+dbit+2;
        hex+dbit+1;
        hex+dbit+0;
        wflip hex+w, switch, borrow1
      end:
        wflip hex+w, switch, borrow0
    }

    //  Time Complexity: n*phi
    // Space Complexity: n(1.5phi+23)
    def dec n, hex @ end {
        rep(n, i) .dec.step hex+i*dw, end
      end:
    }
    ns dec {
        def step hex, end @ next {
            ..dec1 hex, end, next
          next:
        }
    }


    //  Time Complexity: n*(phi+4)
    // Space Complexity: n(1.5phi+27)
    def neg n, hex {
        .not n, hex
        .inc n, hex
    }
}



// ---------- Memory Manipulation:


ns hex {

    //  Time Complexity: phi
    // Space Complexity: phi+27
    def zero x {
        .xor x, x
    }

    //  Time Complexity: n*phi
    // Space Complexity: n*(phi+26)
    def zero n, x {
        rep (n, i) .zero x+i*dw
    }

    //  Time Complexity: 2phi
    // Space Complexity: phi+53
    def mov dst, src {
        .zero dst
        .xor dst, src
    }

    //  Time Complexity: n*(2phi)
    // Space Complexity: n*(phi+52)
    def mov n, dst, src {
        rep(n, i) .mov dst+i*dw, src+i*dw
    }

    //  Time Complexity: phi+4
    // Space Complexity: phi+31
    def set hex, val {
        .zero hex
        wflip hex+w, (val > 0xf ? 0xf : (val < 0 ? 0 : val)) * dw
    }

    //  Time Complexity: 3phi
    // Space Complexity: 3phi+79
    def swap hex1, hex2 {
        .xor hex1, hex2
        .xor hex2, hex1
        .xor hex1, hex2
    }

    //  Time Complexity: n*(3phi)
    // Space Complexity: n*(3phi+78)
    def swap n, hex1, hex2 {
        rep(n, i) .swap hex1+i*dw, hex2+i*dw
    }
}



// ---------- Conditional Jump


ns hex {
    //  Time Complexity: phi
    // Space Complexity: 1.5phi+25
    def if_flags hex, flags, l0, l1 @ switch, end0, end1 {
        wflip hex+w, switch, hex
        pad 16
      switch:
        rep(16, i) comp_if (flags>>i)&1, end0, end1
      end0:
        wflip hex+w, switch, l0
      end1:
        wflip hex+w, switch, l1
    }

    //  Time Complexity: phi
    // Space Complexity: 1.5phi+25
    def if hex, l0, l1 {
        .if_flags hex, 0xfffe, l0, l1
    }
    def if0 hex, l0 @ l1 {
        .if hex, l0, l1
      l1:
    }
    def if1 hex, l1 @ l0 {
        .if hex, l0, l1
      l0:
    }

    //  Time Complexity: n*phi
    // Space Complexity: n(1.5phi+23)
    def if n, hex, l0, l1 {
        rep(n-1, i) .if1 hex+i*dw, l1
        .if hex+(n-1)*dw, l0, l1
    }
    def if0 n, hex, l0 @ l1 {
        .if n, hex, l0, l1
      l1:
    }
    def if1 n, hex, l1 @ l0 {
        .if n, hex, l0, l1
      l0:
    }
}



// ---------- IO


ns hex {

    //  Time Complexity: phi+4
    // Space Complexity: phi+51  phi-4+15+16+24
    def print hex, big_flag @ switch, print_0, print_2, print_4, print_6, print_8, print_a, print_b, print_d, print_f, end < IO {
        wflip hex+w, switch, hex
        pad 16
      switch:
        IO+0;print_0    //  0
        IO+1;print_0    //  1
        IO+0;print_2    //  2
        IO+1;print_2    //  3
        IO+0;print_4    //  4
        IO+1;print_4    //  5
        IO+0;print_6    //  6
        IO+1;print_6    //  7
        IO+0;print_8    //  8
        IO+1;print_8    //  9

        IO+1;print_a    //  a
        IO+0;print_b    //  b
        IO+1;print_b    //  c
        IO+0;print_d    //  d
        IO+1;print_d    //  e
        IO+0;print_f    //  f

      print_0:
        IO+0;
        IO+0;
        IO+0;
        IO+1;
        IO+1;
        IO+0;
        IO+0;end
      print_2:
        IO+1;print_0+1*dw
      print_4:
        IO+0;
        IO+1;print_0+2*dw
      print_6:
        IO+1;print_4+1*dw
      print_8:
        IO+0;
        IO+0;
        IO+1;print_0+3*dw
      print_a:
        IO+0;
        IO+0;
        IO+0;
        IO+0;
        IO+(big_flag ? 0 : 1);
        IO+1;print_0+6*dw
      print_b:
        IO+1;print_a+1*dw
      print_d:
        IO+0;
        IO+1;print_a+2*dw
      print_f:
        IO+1;print_d+1*dw

      end:
        wflip hex+w, switch
    }

    //  Time Complexity: phi+4
    // Space Complexity: phi+42
    def print n, x, big_flag {
        rep (n, i) .print x+(n-1-i)*dw, big_flag
    }

    //  Time Complexity: 2phi+7
    // Space Complexity: 2phi+39
    def input4 hex @ flip0, flip1, flip2, flip3, end < IO {
        .zero hex
        wflip IO+w, flip0, IO

        pad 8
      flip0:
        IO+dbit+1;IO
        hex+dbit+0;flip0
      flip1:
        IO+dbit+2;IO
        hex+dbit+1;flip1
      flip3:
        wflip IO+w, flip3, end
        hex+dbit+3;flip3
      flip2:
        IO+dbit+1;IO
        hex+dbit+2;flip2
      end:
    }

    //  Time Complexity: 4phi+14
    // Space Complexity: 4phi+70
    def input_ascii hex0, hex1 {
        .input4 hex0
        .input4 hex1
    }

    //  Time Complexity: 6phi+14
    // Space Complexity: 9.5phi+168
    def input_hex hex, error @ try_dec, do_dec, do_hex, switch, finish_hex, upper, end {
        .input_ascii hex, upper
        .if_flags upper, (1<<4)|(1<<6), try_dec, do_hex
      try_dec:
        .if_flags upper, (1<<3), error, do_dec

      do_dec:
        .if_flags hex, (1<<10)-1, error, end

      do_hex:
        wflip hex+w, switch, hex

      finish_hex:
        hex+dbit+3;
        wflip hex+w, switch, end

        pad 16
      switch:
        wflip hex+w, switch, error  //  0
        hex+dbit+1;switch+2*dw      //  1
        hex+dbit+0;finish_hex       //  2
        hex+dbit+2;switch+1*dw      //  3
        hex+dbit+0;finish_hex       //  4
        hex+dbit+1;switch+2*dw      //  5
        hex+dbit+0;finish_hex       //  6
        ;switch                     //  7
        ;switch
        ;switch
        ;switch
        ;switch
        ;switch
        ;switch
        ;switch
        ;switch

      upper: hex
      end:
    }
}
