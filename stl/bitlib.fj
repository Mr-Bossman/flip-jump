// Every line is (a bit) bananas!
// Implementation of single bit-variables operations

// should be assembled with an (exactly one) libXX.fjm file
// This file is independent of the bit-width, and uses the consts defined at libXX.fjm

// Everything after // is ignored, everything before first : is ignored too, and every whitespace is ignored (besides new line)
// An opcode is:  F;L  F  ;L  or just  ;  (no F => F=temp;  no L => L=next)


// TODO - implement pointer dereference (read and write)



// ---------- Input / Output:


.def output x $ label_ptr base_jump_label end
    .xor label_ptr x
  label_ptr:
    ;l0
    ..pad 2
  base_jump_label:
    IO+0;end
    IO+1
    .not label_ptr
  end:
.end



// ---------- Memory Variables:


.def bit0
    ;0
.end

.def bit1
    ;dw
.end



// ---------- Memory Manipulation:


.def zero x
    .xor x x
.end


.def one x
    .zero x
    .not x
.end


// Unsafe for dst==src (equals .zero dst)
.def mov dst src
    .zero dst
    .xor dst src
.end

.def safe_mov dst src $ __zero
    .zero __zero
    .xor __zero src
    .zero dst
    .xor dst __zero
    .skip
  __zero:
    .bit0
.end


// ---------- Unconditional Jump


.def skip
    ;> + dw
.end



// ---------- Conditional Jump


.def if x l0 l1 $ label_ptr base_jump_label
    .xor label_ptr x
  label_ptr:
    ;base_jump_label
    ..pad 2
  base_jump_label:
    ;l0
    label_ptr + dbit;l1
.end

.def if1 x l1 $ end
    .if x end l1
  end:
.end

.def if0 x l0 $ end
    .if x l0 end
  end:
.end


.def cmp a b lt eq gt $ a_is1_label
    .if1 a a_is1_label
    .if b eq lt
  a_is1_label:
    .if b gt eq
.end



// ---------- Logical Macros:


.def xor dst src
    .naked_xor dst + dbit src
.end

.def naked_xor dst src $ base_jump_label cleanup
    ..flip_by_dbit src+w base_jump_label
    ;src
    ..pad 2
  base_jump_label:
    ;cleanup
    dst;cleanup
  cleanup:
    ..flip_by_dbit src+w base_jump_label
.end


.def or dst src $ end
    .if0 src end
    .one dst
  end:
.end


.def and dst src $ end
    .if1 src end
    .zero dst
  end:
.end


.def not dst
    dst + dbit;
.end



// ---------- Arithmetical Macros


.def inc dst
    .inc_carry1 dst
.end
.def inc_carry1 dst $ carry_label
    .inc dst carry_label
    .skip
  carry_label:
    .bit1
.end

// Unsafe for dst==carry (but there is no reason in calling it that way)
.def inc dst carry $ end
    .if0 carry end
    .not dst
    .if0 dst end
    .not carry
  end:
.end


.def dec x
    .not x
    .inc x
    .not x
.end


.def neg x
    .not x
    .inc x
.end


.def add dst src
    .add_carry0 dst src
.end
.def add_carry0 dst src $ carry_label
    .add dst src carry_label
    .skip
  carry_label:
    .bit0
.end
.def add_carry1 dst src $ carry_label
    .add dst src carry_label
    .skip
  carry_label:
    .bit1
.end

// Unsafe for dst==carry (but there is no reason in calling it that way)
.def add dst src carry $ temp_src
    .mov temp_src src
    .inc dst temp_src
    .inc dst carry
    .or  carry temp_src
    .skip
  temp_src:
    .bit0
.end


.def sub dst src
    .not src
    .add_carry1 dst src
    .not src
.end

