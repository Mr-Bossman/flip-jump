// This fj program prints all the prime numbers (as decimal numbers) up to a number n (given by input).

hw = w/4
PRIMES_MEMORY_START = (1 << (w-2))   // 1/4 of the memory
PRIMES_MEMORY_LENGTH = (1 << (w-1))  // 1/2 of the memory   # TODO should work with 1/2 and 1/2. check where does the wflips go. it should be well documented.
FIRST_PRIME = 5
MAX_PRIMES = PRIMES_MEMORY_LENGTH / dw
stl.startup_and_init_all


// TODO remove when finished. also remove temp1: and temp2:
// in order to "mark", we'll use a different primes_ptr. maybe we need one for read, and one for write.
//set_primes_ptr primes_ptr, temp1
//hex.xor_to_ptr primes_ptr, temp1
//set_primes_ptr primes_ptr, temp2
//hex.xor_to_ptr primes_ptr, temp2

// The main program

  input_max_prime n, primes_ptr_n
  handle_small_n n, end

prime_loop_if:
  hex.cmp hw, p, n, prime_loop, prime_loop, end
prime_loop:
  debug.print_primes_ptr_index primes_ptr // TODO remove when complete
  if1_ptr primes_ptr, next_prime
  print_int hw, p  // TODO save ton of times by declaring p "dec", with dec.vec, dec.set, dec.add and dec.print.

  // TODO mark every p*(p+i) as not prime (stop when reached > n)
next_prime:
  set_next_prime p, primes_ptr, mark_primes_ptr, is_add_4, prime_loop_if


end:
  stl.loop


// Variables:

n: hex.vec hw
primes_ptr_n: hex.vec hw, PRIMES_MEMORY_START

p: hex.vec hw, FIRST_PRIME
primes_ptr: hex.vec hw, PRIMES_MEMORY_START + FIRST_PRIME * dw
mark_primes_ptr: hex.vec hw, PRIMES_MEMORY_START + FIRST_PRIME*FIRST_PRIME * dw

temp1: hex.vec hw, 37
//temp2: hex.vec hw, 41

is_add_4: bit.bit (FIRST_PRIME % 6) == 1  // if 0: add 2, else: add 4.
ONE: hex.hex 1

// Segments:

segment PRIMES_MEMORY_START
    reserve PRIMES_MEMORY_LENGTH


// Macro definitions:


// if n < 2, print nothing and exit. if n == 2 print 2 and exit. else, print 2,3 and continue.
def handle_small_n n, finish_address @ equals_2, print_2_3_then_start, two, continue_address {
    hex.cmp hw, n, two, finish_address, equals_2, print_2_3_then_start
  equals_2:
    stl.output "2\n"
    ;finish_address
  print_2_3_then_start:
    stl.output "2\n3\n"
    ;continue_address

  two: hex.vec hw, 2

  continue_address:
}


// Time Complexity: w(5.5@) + 24@+43
//   p += 2/4 (depends on the is_add_4 flag).
//   primes_ptr += 2/4 * dw. flip the flag, and jump to continue_address.
def set_next_prime p, primes_ptr, mark_primes_ptr, is_add_4, continue_address @ p_add_2, p_add_4 {
    bit.if is_add_4, p_add_2, p_add_4
  p_add_2:
    set_next_prime_mark_ptr mark_primes_ptr, p, 0
    hex.add_constant hw, primes_ptr, 2 * dw
    hex.add_constant hw, p, 2
    is_add_4+dbit; continue_address
  p_add_4:
    set_next_prime_mark_ptr mark_primes_ptr, p, 1
    hex.add_constant hw, primes_ptr, 4 * dw
    hex.add_constant hw, p, 4
    is_add_4+dbit; continue_address
}


// Advances mark_primes_ptr to point to the current PRIMES_MEMORY_START + p*p * dw.
//   if is_add_2:  mark_primes_ptr += ((p+2)^2 - p^2) * dw
//   if is_add_4:  mark_primes_ptr += ((p+4)^2 - p^2) * dw
// note: must be called before p was incremented.
def set_next_prime_mark_ptr mark_primes_ptr, p, is_add_4 {
    _set_next_prime_mark_ptr mark_primes_ptr, p, is_add_4, is_add_4+2+#w
}
// Time Complexity: w(5.5@) + 5@+12
// Advances mark_primes_ptr to point to the current PRIMES_MEMORY_START + p*p * dw  (basically adds dw times 4p+4 / 8p+16, based on is_add_4).
//   for p_add_2 call with (p,0,2+#w), for p_add_4 call with (p,1,3+#w)
// note: must be called before p was incremented.
def _set_next_prime_mark_ptr mark_primes_ptr, p, inc_offset, shift_size @ bit_p, p_squared_diff, end {
    stl.hex2bit hw, bit_p, p
    bit.inc w-inc_offset, bit_p + dw*inc_offset
    bit.shl w, shift_size, bit_p
    stl.bit2hex w, p_squared_diff, bit_p
    hex.add hw, mark_primes_ptr, p_squared_diff
    ;end

  bit_p: bit.vec w
  p_squared_diff: hex.vec dw

  end:
}


// print hex[:n] as a decimal integer.
def print_int n, hex @ bit, end{
    stl.hex2bit n, bit, hex
    bit.print_dec_int 4*n, bit
    stl.output '\n'
    ;end

  bit: bit.vec 4*n

  end:
}


// if *hex_ptr != 0 goto l1.
def if1_ptr hex_ptr, l1 @ l0 {
    if_ptr hex_ptr, l0, l1
  l0:
}


// if *hex_ptr == 0 goto l0, else goto l1.
def if_ptr hex_ptr, l0, l1 @ ptr_value {
    hex.zero ptr_value
    hex.xor_from_ptr ptr_value, hex_ptr
    hex.if ptr_value, l0, l1

  ptr_value: hex.hex
}


// primes_ptr = PRIMES_MEMORY_START + p*dw
def set_primes_ptr primes_ptr, p @ p_offset, end {
    hex.set hw, primes_ptr, PRIMES_MEMORY_START
    hex.mov hw, p_offset, p
    shl_hex hw, p_offset, #w
    hex.add hw, primes_ptr, p_offset
    ;end

  p_offset: hex.vec hw

  end:
}


// hex[:n] <<= shift
def shl_hex n, hex, shift {
    rep(shift/4, i) hex.shl_hex n, hex
    rep(shift%4, i) hex.shl_bit n, hex
}


// n = input_decimal_number(). check that n is smaller than MAX_PRIMES.
// primes_ptr_n = PRIMES_MEMORY_START + n*dw
def input_max_prime n, primes_ptr_n @ set_primes_ptr_n, bit_n, max_n, raise_more_than_max_primes, end {
    stl.output "Search primes up to: "
    input_decimal_number w, bit_n
    stl.bit2hex w, n, bit_n

    hex.cmp hw, n, max_n, set_primes_ptr_n, raise_more_than_max_primes, raise_more_than_max_primes
  set_primes_ptr_n:
    set_primes_ptr primes_ptr_n, n
    ;end

  bit_n: bit.vec w
  max_n: hex.vec hw, MAX_PRIMES

  raise_more_than_max_primes:
    raise_error "The input number should be less than ((1 << (w-2)) / w).\n  For w=16 it's 1024.\n  For w=32 it's ~33M.\n  For w=64 it's ~7e16."

    end:
}


// bit[:n] = input_ascii_as_decimal. expects \n at finish, and no other characters other then '0'-'9'.
//   example: for input "1234\n" does bit[:n]=1234.
def input_decimal_number n, bit \
        @ input_decimal_digit, end, dec_digit, is_error, ascii, i, i_start, \
        error_handler, newline, raise_not_number_error {
    bit.zero n, bit
    bit.mov #n, i, i_start

  input_decimal_digit:
    bit.if0 #n, i, end
    bit.input ascii
    bit.ascii2dec is_error, dec_digit, ascii
    bit.if1 is_error, error_handler
    bit.mul10 n, bit
    bit.add n, bit, dec_digit
    bit.dec #n, i
    ;input_decimal_digit

  dec_digit: bit.vec n
  newline: bit.vec 8, '\n'
  is_error: bit.bit
  ascii: bit.vec 8
  i: bit.vec #n
  i_start: bit.vec #n, n

  error_handler:
    bit.cmp 8, ascii, newline, raise_not_number_error, end, raise_not_number_error
  raise_not_number_error:
    raise_error "Bad number given. The number should be positive, only digits, and end with a new-line."

  end:
}


// pretty way of printing an error and then exiting.
def raise_error msg {
    stl.output "\n\nError:\n"
    stl.output msg
    stl.output "\nExiting program.\n"
    stl.loop
}


ns debug {
    // For primes_ptr == (PRIMES_MEMORY_START_VAR + p * dw), print the p.
    def print_primes_ptr_index primes_ptr @ bit_prime_index, PRIMES_MEMORY_START_VAR, end {
        stl.output "primes_ptr = &primes["
        stl.hex2bit hw, bit_prime_index, primes_ptr
        bit.sub w, bit_prime_index, PRIMES_MEMORY_START_VAR
        bit.shr w, #w, bit_prime_index
        bit.print_dec_int w, bit_prime_index
        stl.output "]\n"
        ;end

      bit_prime_index: hex.vec w
      PRIMES_MEMORY_START_VAR: bit.vec w, PRIMES_MEMORY_START
      end:
    }
}
