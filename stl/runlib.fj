// w = ??       // memory and operands width. Is defined at compile time.
dw   = 2 * w    // double word size
dbit = w + #w   // the bit-distance from the variable's start, to the bit value (w + w_width)



// Startup Macro - should be the first piece of code in your program.
def startup > IO, code_start {
    ;code_start     // 0w;1w : first code to run
  IO:
    ;0              // 2w;3w : sets the io_handler to address 0 (good for a future wflip)

  code_start:
                    // 4w;5w : start of code
}



// ---------- Basic Functionality


// Complexity: 1
//   macro for 1 flip-jump op
def fj f, j {
    f;j
}


// Complexity: @
//   macro for 1 wflip op
def wflip_macro dst, val {
    wflip dst, val
}


// Complexity: @
//   macro for 1 wflip op (with jump)
def wflip_macro dst, val, jmp_addr {
    wflip dst, val, jmp_addr
}


//// @note - padding can also be implemented in fj itself! (but the saved-word pad is more compile-time efficient)
////   pad zeros up to the address
//def pad address @ pad_start {
//  pad_start:
//    rep((0-pad_start/(2*w))%address, i) fj 0, 0
//}



// ---------- Compilation Time Comparisons:
// Complexity: 1


// if expression is 0 (compilation time), jump to l0. else jump to l1
def comp_if expr, l0, l1 {
    ; expr ? l1 : l0
}

// if expression is 0 (compilation time), jump to l0. else continue
def comp_if0 expr, l0 @ continue {
    comp_if expr, l0, continue
  continue:
}

// if expression is not 0 (compilation time), jump to l1. else continue
def comp_if1 expr, l1 @ continue {
    comp_if expr, continue, l1
  continue:
}


// if expr != 0 (compilation time), flip the given bit
def comp_flip_if bit, expr {
    (expr ? bit : 0);
}



// ---------- Unconditional Jumps
// Complexity: 1


// skip the next flip-jump op
def skip {
    ;$ + dw
}


// finish (loop to self)
def loop {
    ;$ - dw
}



// ---------- Input Handler


// sets the input handlers. When inputting 0 - in0_handler will be called, and for 1 - in1_handler will be called.
def default_input in0_handler, in1_handler @ io_handler, end < IO {
    wflip IO+w, io_handler, end
    pad 2
  io_handler:
    ;in0_handler
    ;in1_handler
  end:
}
