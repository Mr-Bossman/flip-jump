// Every line is (a bit) bananas!
// Implementation of single bit-variables operations

// should be assembled with an (exactly one) libXX.fjm file
// This file is independent of the bit-width, and uses the consts defined at libXX.fjm

// Everything after // is ignored, everything before first : is ignored too, and every whitespace is ignored (besides new line)
// An opcode is:  F;L  F  ;L  or just  ;  (no F => F=0;  no L => L=next)

// Complexity note: phi is log2 of the total number of fj operations, counting .wflip* as one.



// ---------- Compilation Time:
// Complexity: 1


comp_if expr, l0, l1 {
    ; expr ? l1 : l0
}

comp_if0 expr, l0 @ l1 {
    .comp_if expr l0 l1
  l1:
}

comp_if1 expr, l1 @ l0 {
    .comp_if expr l0 l1
  l0:
}


comp_flip_if bit, expr {
    (expr ? bit : 0);
}


// ---------- Memory Variables:
// Size Complexity: 1


bit value {
    ; value ? dw : 0
}

bit {
    .bit 0
}



// ---------- Memory Manipulation:


// Complexity: phi+2
zero x {
    .xor x x
}


// Complexity: phi+3
one x {
    .zero x
    .not x
}


////Complexity: 2phi + 9
//__if_mov dst src @ l0 l1 flip end {
//    .if src l0 l1
//    l0: .if dst end flip
//    l1: .if dst flip end
//    flip:   .not dst
//    end:
//}


// safe even for dst==src !
// Complexity: 2phi+5
mov dst, src @ do_mov, end {
    .comp_if dst-src end do_mov
  do_mov:
    .zero dst
    .xor dst src
  end:
}


//Complexity: 2phi+10
swap a, b @ a0, a1, notnot, end {
    .if a a0 a1
  a0:
    .if b end flip
  a1:
    .if b flip end
  notnot:
    .not a
    .not b
  end:
}



// ---------- Unconditional Jump
// Complexity: 1


skip {
    ;$ + dw
}


loop {
    ;$ - dw
}



// ---------- Conditional Jump


// Complexity: phi+4
if x, l0, l1 @ label_ptr, base_jump_label {
    .xor label_ptr x
  label_ptr:
    ;base_jump_label
    .pad 2
  base_jump_label:
    ;l0
    label_ptr + dbit;l1
}

if1 x, l1 @ end {
    .if x end l1
  end:
}

if0 x, l0 @ end {
    .if x l0 end
  end:
}


// Complexity: 2phi+8
cmp a, b, lt, eq, gt @ a_is1_label {
    .if1 a a_is1_label
    .if b eq lt
  a_is1_label:
    .if b gt eq
}



// ---------- Logical Macros:


// Complexity: phi+2
xor dst, src {
    .exact_xor dst + dbit src
}

exact_xor dst, src @ base_jump_label, cleanup {
    .wflip src+w base_jump_label
    ;src
    .pad 2
  base_jump_label:
    ;cleanup
    dst;
  cleanup:
    .wflip src+w base_jump_label
}

// Complexity: phi+3
double_exact_xor dst1, dst2, src @ base_jump_label, cleanup {
    .wflip src+w base_jump_label
    ;src
    .pad 2
  base_jump_label:
    ;cleanup
    dst1;
    dst2;
  cleanup:
    .wflip src+w base_jump_label
}


// Complexity: 2phi+7
or dst, src @ end {
    .if0 src end
    .one dst
  end:
}


// Complexity: 2phi+6
and dst, src @ end {
    .if1 src end
    .zero dst
  end:
}


// Complexity: 1
not dst {
    dst + dbit;
}

exact_not dst {
    dst;
}



// ---------- Arithmetical Macros


// Unsafe for dst==carry (but there is no reason in calling it that way)
// Complexity: 2phi+10
inc1 dst, carry @ end {
    .if0 carry end
    .not dst
    .if0 dst end
    .not carry
  end:
}


// Unsafe for dst==carry (but there is no reason in calling it that way)
// Complexity: 8phi+33
add1 dst, src, carry @ _src {
    .mov _src src
    .inc1 dst _src
    .inc1 dst carry
    .or carry _src
    .skip
  _src:
    .bit 0
}
