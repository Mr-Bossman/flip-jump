ns bit {
    // Complexity @+2
    //   outputs the bit 'x'.
    def output x @ label_ptr, base_jump_label, end < IO {
        .xor label_ptr, x
      label_ptr:
        ;base_jump_label
        pad 2
      base_jump_label:
        IO+0;end
        IO+1;
        .not label_ptr
      end:
    }


    // Complexity 8@+16
    //   outputs a byte from x[:8] (a bit vector. from lsb to msb).
    def print x {
        rep(8, i) .output x+i*dw
    }

    // Complexity n(8@+16)
    //   outputs n bytes from x[:8n] (a bit vector. from lsb to msb).
    def print n, x {
        rep(n, i) .print x+8*i*dw
    }



    // Complexity min(n, len+1)*(16@+32)
    //   prints the string at x[:8n], or until the reaches the first '\0' (the earlier).
    def print_str n, x @ end {
        rep(n, i) ._.print_str_one_char x+8*i*dw, end
      end:
    }
    ns _ {
        def print_str_one_char char, end {
            ..if0 8, char, end
            ..print char
        }
    }


    // Complexity: @+9
    //   prints the ascii character '0'/'1', based on x's value.
    // x is a bit.
    def print_as_digit x {
        .output x
        rep(7, i) output_bit ('0'>>(i+1)) & 1
    }

    // Complexity: @+9
    //   prints x[:n] as n ascii-characters ('0's and '1's, lsb first).
    // x is a bit[:n], and n is a size constant.
    def print_as_digit n, x {
        rep(n, i) .print_as_digit x+(n-1-i)*dw
    }
}



// ---------- Print Hex Int


ns bit {
    // Complexity: n(7@+11)
    //    print x[:n] as an unsigned hexadecimal number, without leading zeros (digits & capital-letters).
    //
    // x_prefix (constant): print with the "0x" prefix.
    //
    // @Assumes n can be divided by 4.
    def print_hex_uint n, x, x_prefix @ after_print_x, printed_flag, end {
        comp_if0 x_prefix, after_print_x
        output '0'
        output 'x'
      after_print_x:

        .zero printed_flag
        rep(n/4, i) .print_hex_uint.print_digit x+(n/4-1-i)*4*dw, printed_flag

        .if1 printed_flag, end
        output '0'
        ;end

      printed_flag:
        bit
      end:
    }
    //Comp: 29@+44
    ns print_hex_uint {
        def print_digit hex, printed_flag @ continue, ascii, end {
            ..if1 4, hex, continue
            ..if1 printed_flag, continue
            ;end

          continue:
            ..one printed_flag
            ..hex2ascii ascii, hex
            ..print ascii
            ;end

          ascii:
            ..vec 8
          end:
        }
    }


    // Complexity: n(9@+18)
    //    print x[:n] as a signed hexadecimal number, without leading zeros (digits & capital-letters).
    //
    // x_prefix (constant): print with the "0x" prefix.
    //
    // @Assumes n can be divided by 4.
    def print_hex_int n, x, x_prefix @ do_print {
        .if0 x+(n-1)*dw, do_print
        output '-'
        .neg n, x
      do_print:
        .print_hex_uint n, x, x_prefix
    }
}



// ---------- Print Dec Int


ns bit {
//// Complexity: n^2(8phi+29) + nb(17phi+74)
    //// Space Complexity: ~O(130n^2)
    //def print_dec_uint n, x @ printed_flag, curr_ten, tens, val, r, end {
    //    .zero printed_flag
    //
    //    .zero n+4, curr_ten
    //    .not curr_ten
    //
    //    .zero n+7, val
    //    .xor n, val, x
    //
    //    rep(n*28/93+2, i) ._.print_dec_uint_put_pow_ten n+4, tens+i*(n+4)*dw, curr_ten, val
    //
    //    rep(n*28/93+2, i) ._.print_dec_uint_char n+4, val, tens+(n*28/93+2-1-i)*(n+4)*dw, printed_flag
    //
    //    .if1 printed_flag, end
    //    output '0'
    //    ;end
    //
    //  printed_flag:
    //    bit
    //  curr_ten:
    //    .vec n+4
    //  tens:
    //    .vec (n*28/93+2)*(n+4)      // 28/93 is very close from above to log10(2)
    //  val:
    //    .vec n+7
    //  r:
    //    .vec n
    //  end:
    //}
    //ns _ {
    //    //Comp: n(18phi+60)
    //    def print_dec_uint_put_pow_ten n, dst, curr_ten, top @ put, end {
    //        .zero n, dst
    //        .cmp n, curr_ten, top, put, put, end
    //      put:
    //        .xor n, dst, curr_ten
    //        .mul10 n, curr_ten
    //      end:
    //    }
    //    //Comp: n(9phi+36) + 7b*(8phi+35)
    //    def print_dec_uint_char n, v, curr_ten, printed_flag @ do_print, dec, ascii, end {
    //        .if0 n, curr_ten, end
    //        .zero 4, dec
    //        rep(4, i) ._.print_dec_uint_sub_curr_ten n, v, curr_ten, dec, 3-i
    //
    //        .if1 4, dec, do_print
    //        .if1 printed_flag, do_print
    //        ;end
    //
    //      do_print:
    //        .one printed_flag
    //        dec2ascii ascii, dec
    //        print ascii
    //        ;end
    //
    //      dec:
    //        .vec 4
    //      ascii:
    //        .vec 8
    //      end:
    //    }
    //    //Comp: worst: n(2phi+8) + 3.3b*(8phi+35),  avg: n(2phi+8) + 1.7b*(8phi+35)
    //    def print_dec_uint_sub_curr_ten n, v, curr_ten, dec, index @ do_sub, end {
    //        .cmp n, v+index*dw, curr_ten, end, do_sub, do_sub
    //      do_sub:
    //        .sub n, v+index*dw, curr_ten
    //        .not dec+index*dw
    //      end:
    //    }
    //}
    //
    //
    //
    //def print_dec_int n, x @ do_print {
    //    .if0 x+(n-1)*dw, do_print
    //    output '-'
    //    .neg n, x
    //  do_print:
    //    .print_dec_uint n, x
    //}


    // Time  Complexity: n^2(2phi+8)
    // Space Complexity: n(14phi+51)
    def print_dec_uint n, x @ start_printing, xor, end_xor, dst, src, print_buffer, print_buffer_flag, div10, zero_flag, ret_reg, end {
        .mov n, src, x
        .zero zero_flag

        // the next three takes ~ (28/93n)*(phi+2 + 11phi+27 + 5phi+28) = n(5.12phi+17.17) < n(6phi+17.5) space
        .zero n*28/93+1, print_buffer_flag   // all chars are off
        rep(n*28/93+1, i) ._.print_dec_uint.div10_step div10, xor, ret_reg, src, print_buffer+i*4*dw, print_buffer_flag+i*dw, zero_flag, start_printing
      start_printing:
        rep(n*28/93+1, i) ._.print_dec_uint.print_char print_buffer+(n*28/93-i)*4*dw, print_buffer_flag+(n*28/93-i)*dw

        ;end

      div10:
        .div10 n, dst, src
        fret ret_reg
      xor:
        .xor n, src, dst     // TODO: can double_exact_xor and zero dst too - so to save the "zero n dst" inside the next div10 (save ~n/3(phi+1))
        .if1 n, dst, end_xor
        .not zero_flag
      end_xor:
        fret ret_reg

        // takes n(2+28/93*5) = 3.5n space
        dst: .vec n
        src: .vec n
        print_buffer:      .vec (n*28/93+1)*4
        print_buffer_flag: .vec  n*28/93+1
        zero_flag: bit
        ret_reg: 0;0
      end:
    }
    ns _ {
        ns print_dec_uint {
            // Time  Complexity: n(6phi+25)
            // Space Complexity: 11phi+27
            def div10_step div10, xor, ret_reg, src, ascii_res, char_flag, zero_flag, start_printing {
                ...if1 zero_flag, start_printing
                fcall div10, ret_reg
                ...zero 4, ascii_res
                rep(4, i) ...double_exact_xor ascii_res+dbit+i*dw, src+dbit+i*dw, src+i*dw
                ...not char_flag
                fcall xor, ret_reg
            }

            // Complexity: 5phi+28
            def print_char ascii4, char_flag @ end {
                ...if0 char_flag, end
                rep(4, i) ...output ascii4+i*dw
                rep(4, i) output_bit (0x3>>i)&1
              end:
            }
        }
    }


    def print_dec_int n, x @ do_print {
        .if0 x+(n-1)*dw, do_print
        output '-'
        .neg n, x
      do_print:
        .print_dec_uint n, x
    }
}
