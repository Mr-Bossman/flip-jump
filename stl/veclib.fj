// Every line is (a vector of) bananas!
// Implementation of vector of bit-variables operations

// should be assembled with both bitlib.fjm and (exactly one) libXX.fjm files
// This file is independent of the bit-width, and uses the consts defined at libXX.fjm

// Everything after // is ignored, everything before first : is ignored too, and every whitespace is ignored (besides new line)
// An opcode is:  F;L  F  ;L  or just  ;  (no F => F=temp;  no L => L=next)


// TODO - implement every method 4,8,16,32,64 versions, and then implement pointer dereference (read and write)
// TODO - maybe create a script that will create all the versions?


// ---------- Memory Manipulation:


.def mov n dst src
    .rep n i
        //.mov dst[dw*i] src[dw*i]
    .end
.end



// ---------- Conditional Jump


.def cmp2 a b lt eq gt $ middle_check
    .cmp a[dw] b[dw] lt middle_check gt
  middle_check:
    .cmp a b lt eq gt
.end

.def cmp n a b lt eq gt

.end



// ---------- Logical Macros:


.def xor2 dst src
    .xor dst src
    .xor dst[dw] src[dw]
.end


.def or2 dst src
    .or dst src
    .or dst[dw] src[dw]
.end


.def and2 dst src
    .and dst src
    .and dst[dw] src[dw]
.end


.def not2 dst
    .not dst src
    .not dst[dw] src[dw]
.end


.def shl2 x
    .mov x x[dw]
    .zero x[dw]
.end


.def shr2 x
    .mov x[dw] x
    .zero x
.end


.def rol2 x $ rol2_bit_label
    .mov rol2_bit_label x
    .shl2 x
    .mov x[dw] rol2_bit_label
    ;rol2_bit_label[dw]
  rol2_bit_label:
    .bit0
.end


.def ror2 x $ ror2_bit_label
    .mov ror2_bit_label x[dw]
    .shr2 x
    .mov x ror2_bit_label
    ;ror2_bit_label[dw]
  ror2_bit_label:
    .bit0
.end



// ---------- Arithmetical Macros
// carry is both input and output


.def inc2 x
    .inc2_carry1 x
.end
.def inc2_carry1 x $ carry_label
    .inc2 x carry_label
    ;carry_label[dw]
  carry_label:
    .bit1
.end
.def inc2 x carry
    .inc x carry
    .inc x[dw] carry
.end


.def dec2 x
    .not2 x
    .inc2 x
    .not2 x
.end


.def neg2 x
    .not2 x
    .inc2 x
.end


.def add2 dst src
    .add2_carry0 dst src
.end
.def add2_carry0 dst src $ carry_label
    .add2 dst src carry_label
    ;carry_label[dw]
  carry_label:
    .bit0
.end
.def add2_carry1 dst src $ carry_label
    .add2 dst src carry_label
    ;carry_label[dw]
  carry_label:
    .bit1
.end
.def add2 dst src carry
    .add dst src carry
    .add dst[dw] src[dw] carry
.end


.def sub2 dst src
    .not2 src
    .add2_carry1 dst src
    .not2 src
.end

