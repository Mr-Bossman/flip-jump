// ---------- Jump:


ns hex {
    // Complexity: 2w@ + 2
    //   like:  ;*ptr
    //   Jump to the address the pointer points to.
    //   ( to_jump{_var} = ptr.  ==>  ;to_jump )
    // ptr is a bit[:w] that holds an address.
    def ptr_jump ptr < stl.pointers.to_jump, stl.pointers.to_jump_var {
        bit.bit_var_xor w, stl.pointers.to_jump+w, stl.pointers.to_jump_var, stl.pointers.to_jump_var
        bit.bit_var_xor w, stl.pointers.to_jump+w, stl.pointers.to_jump_var, ptr
        ;stl.pointers.to_jump
    }
}



// ---------- Flip:


ns hex {
    // Complexity: 2w@ + @
    //   like:  *ptr;
    //   Flip the address the pointer points to.
    //   ( to_flip{_var} = ptr.  ==>  ;to_flip )
    // ptr is a bit[:w] that holds an address.
    def ptr_flip ptr @ cleanup < stl.pointers.to_flip, stl.pointers.to_flip_var {
        wflip stl.pointers.to_flip+w, cleanup

        bit.bit_var_xor w, stl.pointers.to_flip, stl.pointers.to_flip_var, stl.pointers.to_flip_var
        bit.bit_var_xor w, stl.pointers.to_flip, stl.pointers.to_flip_var, ptr
        ;stl.pointers.to_flip

        pad 4
      cleanup:
        wflip stl.pointers.to_flip+w, cleanup
    }


    // Complexity 2w@ + 2@
    // The stl.comp_flip_if executes in ~##w, which should be much less than @/2 operations.
    //   like:  (*ptr)+dbit;
    //   Flip the address dbit-ahead of what the pointer points to.
    // ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def ptr_flip_dbit ptr {
        rep(#dbit, i) stl.comp_flip_if ptr+dbit+i*dw, (dbit>>i)&1
        .ptr_flip ptr
        rep(#dbit, i) stl.comp_flip_if ptr+dbit+i*dw, (dbit>>i)&1
    }

    // Complexity 2w@ + 2@+2
    //   like:  bit.xor *ptr, bit
    // ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def xor_to_ptr ptr, bit @ end {
        bit.if0 bit, end
        .ptr_flip_dbit ptr
      end:
    }


    // Complexity 3w@  (actually a bit smaller, 2w@+3w + (@-2)^2)
    //   like:  wflip *ptr, value
    // ptr is a bit[:w] that holds an address, which we assume is w-aligned.
    def ptr_wflip ptr, value < stl.pointers.to_flip, stl.pointers.to_flip_var {
        bit.bit_var_xor w, stl.pointers.to_flip, stl.pointers.to_flip_var, stl.pointers.to_flip_var
        bit.bit_var_xor w, stl.pointers.to_flip, stl.pointers.to_flip_var, ptr
        rep(w, i) .pointers.advance_by_one_and_flip__ptr_wflip (#(i^((i+1)%w))), (value>>i)&1
    }
    ns pointers {
        // Advances *to_flip by 1 (which takes n flips, from bit0 to bit1, bit2,...).
        // If do_flip (value) isn't 0 - than make a flip, like:  to_flip;advance.
        def advance_by_one_and_flip__ptr_wflip n, do_flip @ cleanup, advance < stl.pointers.to_flip {
            stl.comp_if0 do_flip, advance
            wflip stl.pointers.to_flip+w, cleanup, stl.pointers.to_flip
          cleanup:
            wflip stl.pointers.to_flip+w, cleanup, advance

            pad 4
          advance:
            rep(n, i) bit.exact_not stl.pointers.to_flip+i
        }
    }

    // Complexity 3w@  (actually a bit smaller, 2w@+3w+2 + (@-2)^2)
    //   like:  wflip (*ptr)+w, value
    // ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def ptr_wflip_2nd_word ptr, value {
        bit.not ptr + dw*(#w-1)
        bit.ptr_wflip ptr, value
        bit.not ptr + dw*(#w-1)
    }
}



// ---------- Xor


ns hex {
    // Complexity 7w@ (actually a bit smaller, 6w@+6w+8 + 2(@-2)^2)
    //   like:  bit.xor dst, *ptr
    // dst is a bit. ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def xor_from_ptr dst, ptr {
        .exact_xor_from_ptr dst+dbit, ptr
    }

    // Complexity 7w@ (actually a bit smaller, 6w@+6w+8 + 2(@-2)^2)
    //   like:  bit.exact_xor dst, *ptr
    // dst is a bit-address. ptr is a bit[:w] that holds an address, which we assume is dw-aligned.
    def exact_xor_from_ptr dst, ptr @ base_jump_label, cleanup {
        .ptr_wflip_2nd_word ptr, base_jump_label

        .ptr_jump ptr
        pad 2
      base_jump_label:
        ;cleanup
        dst;

      cleanup:
        .ptr_wflip_2nd_word ptr, base_jump_label

    }
}



// ---------- Stack


ns hex {
    //  Time Complexity: n(2@)
    // Space Complexity: n(2@+24)
    // Unsafe if dst is stl.pointers.sp.
    //   dst[:n] = sp
    def get_sp dst < stl.pointers.sp {
        bit.mov w, dst, stl.pointers.sp
    }


    //  Time Complexity: 1.067@         // (16/15 * @)
    // Space Complexity: w(1.5@+13)     // actually (w-#w)(1.5@+13)
    //   ptr[:n] += 2w
    def inc_ptr ptr {
        bit.inc w-#w, ptr+#w*dw
    }

    //  Time Complexity: 1.067@         // (16/15 * @)
    // Space Complexity: w(1.5@+13)     // actually (w-#w)(1.5@+13)
    //   ptr[:n] -= 2w
    def dec_ptr ptr {
        bit.dec w-#w, ptr+#w*dw
    }


    //  Time Complexity: 4w@  (actually a bit smaller)
    // Space Complexity: 5w@  (actually a bit smaller)
    //   Like:  stack[++sp] = return_address
    //   Pushes the given return_address to the next cell in the stack (assumes it's zero). Increments sp.
    // return_address is a fj-op address, so we assume is dw-aligned.
    def push_ret_address return_address < stl.pointers.sp {
        .inc_ptr stl.pointers.sp
        .ptr_wflip_2nd_word stl.pointers.sp, return_address
    }

    //  Time Complexity: 4w@  (actually a bit smaller)
    // Space Complexity: 5w@  (actually a bit smaller)
    //   Like:  stack[sp--] = 0
    //   Pops the given return_address from the current cell in the stack (assumes it has the value of the return_address). Decrements sp.
    // return_address is a fj-op address, so we assume is dw-aligned.
    def pop_ret_address return_address < stl.pointers.sp {
        .ptr_wflip_2nd_word stl.pointers.sp, return_address
        .dec_ptr stl.pointers.sp
    }


    //  Time Complexity: 2w@ + 3@+2
    // Space Complexity: w(3.5@+13)
    //   Like:  stack[++sp] = bit
    //   Pushes the given bit to the next cell in the stack (assumes it's zero). Increments sp.
    def push bit < stl.pointers.sp {
        .inc_ptr stl.pointers.sp
        .xor_to_ptr stl.pointers.sp, bit
    }

    //  Time Complexity: 2w@ + 3@+2
    // Space Complexity: w(3.5@+13)
    //   Like:  stack[sp--] = 0
    //   Pops the given bit from the current cell in the stack (assumes it has the value of bit). Decrements sp.
    def pop bit < stl.pointers.sp {
        .xor_to_ptr stl.pointers.sp, bit
        .dec_ptr stl.pointers.sp
    }


    //  Time Complexity: w(10@+10)  (actually a bit smaller, 8w@ + 10w+9 + 2(@-2)^2)
    // Space Complexity: w(11@+20)  (actually a bit smaller, w(9.5@+19) + 2(@-2)^2 + @-1)
    //   Like:  bit = stack[sp]
    //          stack[sp--] = 0
    //   Pops the current stack cell into the the given bit. Decrements sp.
    // bit is only an output parameter
    def pop_res bit < stl.pointers.sp {
        bit.zero bit
        .xor_from_ptr bit, stl.pointers.sp
        .pop bit
    }
}
