// ---------- Jump:



ns hex {
    ns pointers {
        // Space Complexity: w/2+2
        //   Inits the global opcodes and pointer-copies required for the pointers macros.
        //
        // @output-param to_flip:  address of opcode that holds a flipping address in its first word. jumping into it will flip wanted bit.
        // @output-param to_flip_var:  the hex-vector (pointer) that also holds the flipping address.
        // @output-param to_jump:  address of opcode that holds a jumping address in its second word. jumping into it will jump to the wanted address.
        // @output-param to_jump_var:  the hex-vector (pointer) that also holds the jumping address.
        def ptr_init > to_flip, to_jump, to_flip_var, to_jump_var {
          to_flip:
            0;0
          to_jump:
            ;0

          to_flip_var:
            hex.vec w/4, 0
          to_jump_var:
            hex.vec w/4, 0
        }

        //  Time Complexity: w(0.5@+2)
        // Space Complexity: w(0.5@+14)
        //   Sets both to_jump and to_jump_var to point to the given pointer.
        //   (  to_jump{_var} = ptr  )
        // ptr is a hex[:w/4] that holds an address.
        def set_jump_pointer ptr < .to_jump, .to_jump_var {
            ..address_and_variable_xor w/4, .to_jump+w, .to_jump_var, .to_jump_var
            ..address_and_variable_xor w/4, .to_jump+w, .to_jump_var, ptr
        }

        //  Time Complexity: w(0.5@+2)
        // Space Complexity: w(0.5@+14)
        //   Sets both to_flip and to_flip_var to point to the given pointer.
        //   (  to_flip{_var} = ptr  )
        // ptr is a hex[:w/4] that holds an address.
        def set_flip_pointer ptr < .to_flip, .to_flip_var {
            ..address_and_variable_xor w/4, .to_flip, .to_flip_var, .to_flip_var
            ..address_and_variable_xor w/4, .to_flip, .to_flip_var, ptr
        }

        // Space Complexity: n+w/4
        //   Initializes a stack of size n (maximal capacity of n bits / hexs / return-addresses).
        // n is the size of the stack.
        // @output-param sp: the stack pointer. sp always points to the last pushed value (at start - to stack[-1])
        // @output-param stack: the global stack.
        def stack_init n > sp, stack {
          sp:
            hex.vec w/4, .stack-dw

            pad w
          stack:
            bit.vec n, 0
        }
    }
}


ns hex {
    //  Time Complexity: w(0.5@+2)
    // Space Complexity: w(0.5@+14)
        //   like:  ;*ptr
    //   Jump to the address the pointer points to.
    // ptr is a hex[:w/4] that holds an address.
    def ptr_jump ptr < hex.pointers.to_jump {
        .pointers.set_jump_pointer ptr
        ;hex.pointers.to_jump
    }
}



// ---------- Flip:


ns hex {
    //  Time Complexity: w(0.5@+2)  + @
    // Space Complexity: w(0.5@+14) + @
    //   like:  *ptr;
    //   Flip the address the pointer points to.
    // ptr is a hex[:w/4] that holds an address.
    def ptr_flip ptr @ cleanup < hex.pointers.to_flip {
        wflip hex.pointers.to_flip+w, cleanup

        .pointers.set_flip_pointer ptr
        ;hex.pointers.to_flip

        pad 4
      cleanup:
        wflip hex.pointers.to_flip+w, cleanup
    }


    //  Time Complexity: w(0.5@+2)  + 2@
    // Space Complexity: w(0.5@+14) + 2@
    // The stl.comp_flip_if executes in ~##w, which should be much less than @/2 operations.
    //   like:  (*ptr)+dbit;
    //   Flip the address dbit-ahead of what the pointer points to.
    // ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def ptr_flip_dbit ptr {
        rep(#dbit, i) stl.comp_flip_if ptr+dbit+(i/4)*dw+i%4, (dbit>>i)&1
        .ptr_flip ptr
        rep(#dbit, i) stl.comp_flip_if ptr+dbit+(i/4)*dw+i%4, (dbit>>i)&1
    }

    //  Time Complexity: w(0.5@+2)  + 3@+2
    // Space Complexity: w(0.5@+14) + 3@+2
    //   like:  bit.xor *ptr, bit
    // ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def xor_to_ptr ptr, bit @ end {
        bit.if0 bit, end
        .ptr_flip_dbit ptr
      end:
    }


    // Complexity 3w@  (actually a bit smaller, 2w@+3w + (@-2)^2)
    //   like:  wflip *ptr, value
    // ptr is a hex[:w/4] that holds an address, which we assume is w-aligned.
    def ptr_wflip ptr, value {
        .pointers.set_flip_pointer ptr
        rep(w, i) .pointers.advance_by_one_and_flip__ptr_wflip (#(i^((i+1)%w))), (value>>i)&1
    }
    ns pointers {
        // Advances *to_flip by 1 (which takes n flips, from bit0 to bit1, bit2,...).
        // If do_flip (value) isn't 0 - than make a flip, like:  to_flip;advance.
        def advance_by_one_and_flip__ptr_wflip n, do_flip @ cleanup, advance < hex.pointers.to_flip {
            stl.comp_if0 do_flip, advance
            wflip hex.pointers.to_flip+w, cleanup, hex.pointers.to_flip
          cleanup:
            wflip hex.pointers.to_flip+w, cleanup, advance

            pad 4
          advance:
            rep(n, i) bit.exact_not hex.pointers.to_flip+i
        }
    }

    // Complexity 3w@  (actually a bit smaller, 2w@+3w+2 + (@-2)^2)
    //   like:  wflip (*ptr)+w, value
    // ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def ptr_wflip_2nd_word ptr, value {
        ptr+dbit + ((#w-1)/4)*dw + (#w-1)%4;
        hex.ptr_wflip ptr, value
        ptr+dbit + ((#w-1)/4)*dw + (#w-1)%4;
    }
}



// ---------- Xor


ns hex {
    // Complexity 5.5w@
    //   like:  bit.xor dst, *ptr
    // dst is a bit. ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def xor_from_ptr dst, ptr {
        .exact_xor_from_ptr dst+dbit, ptr
    }

    //  Time Complexity: 5.5w@ (exact: 4.5w@+8w+8 + 2(@-2)^2)
    // Space Complexity: 5.5w@ (exact: 4.5w@+8w+20 + 2(@-2)^2)
    //   like:  bit.exact_xor dst, *ptr
    // dst is a bit-address. ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def exact_xor_from_ptr dst, ptr @ base_jump_label, cleanup {
        .ptr_wflip_2nd_word ptr, base_jump_label

        .ptr_jump ptr
        pad 2
      base_jump_label:
        ;cleanup
        dst;

      cleanup:
        .ptr_wflip_2nd_word ptr, base_jump_label

    }
}



// ---------- Ptr ++/--


ns hex {
    //  Time Complexity: 10@+17
    // Space Complexity: w(0.375@ + 3.25)  + 6@+71  (for log(w) in 16,32,64,128)
    //   ptr[:w/4] += 2w
    def inc_ptr ptr {
        hex.inc_shifted w/4, ptr, #w
    }

    //  Time Complexity: 10@+26
    // Space Complexity: w(0.375@ + 3.25)  + 6@+83  (for log(w) in 16,32,64,128)
    //   ptr[:w/4] -= 2w
    def dec_ptr ptr {
        hex.dec_shifted w/4, ptr, #w
    }
}



// ---------- Stack


ns hex {
    //  Time Complexity: 4w@  (actually a bit smaller)
    // Space Complexity: 4w@  (actually a bit smaller)
    //   Like:  stack[++sp] = return_address
    //   Pushes the given return_address to the next cell in the stack (assumes it's zero). Increments sp.
    // return_address is a fj-op address, so we assume is dw-aligned.
    def push_ret_address return_address < hex.pointers.sp {
        .inc_ptr hex.pointers.sp
        .ptr_wflip_2nd_word hex.pointers.sp, return_address
    }

    //  Time Complexity: 4w@  (actually a bit smaller)
    // Space Complexity: 4w@  (actually a bit smaller)
    //   Like:  stack[sp--] = 0
    //   Pops the given return_address from the current cell in the stack (assumes it has the value of the return_address). Decrements sp.
    // return_address is a fj-op address, so we assume is dw-aligned.
    def pop_ret_address return_address < hex.pointers.sp {
        .ptr_wflip_2nd_word hex.pointers.sp, return_address
        .dec_ptr hex.pointers.sp
    }



    // TODO read/write 4-bit values (good for bit/hex/dec) with hex.{push/pop/pop_res}



    //  Time Complexity: w(0.5@+2)  + 13@+19
    // Space Complexity: w(0.875@+5.25) + 9@+73
    //   Like:  stack[++sp] = bit
    //   Pushes the given bit to the next cell in the stack (assumes it's zero). Increments sp.
    def push bit < hex.pointers.sp {
        .inc_ptr hex.pointers.sp
        .xor_to_ptr hex.pointers.sp, bit
    }

    //  Time Complexity: w(0.5@+2)       + 13@+28
    // Space Complexity: w(0.875@+17.25) + 9@+85
    //   Like:  stack[sp--] = 0
    //   Pops the given bit from the current cell in the stack (assumes it has the value of bit). Decrements sp.
    def pop bit < hex.pointers.sp {
        .xor_to_ptr hex.pointers.sp, bit
        .dec_ptr hex.pointers.sp
    }


    //  Time Complexity: w(6@+10)   (for w=64. exact: w(5@+10)        + 14@+36  + 2(@-2)^2)
    // Space Complexity: w(6.5@+20) (for w=64. exact: w(5.375@+25.25) + 10@+117 + 2(@-2)^2)
    //   Like:  bit = stack[sp]
    //          stack[sp--] = 0
    //   Pops the current stack cell into the the given bit. Decrements sp.
    // bit is only an output parameter
    def pop_res bit < hex.pointers.sp {
        bit.zero bit
        .xor_from_ptr bit, hex.pointers.sp
        .pop bit
    }
}
