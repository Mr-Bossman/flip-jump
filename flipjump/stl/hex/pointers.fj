// ---------- Jump:



ns hex {
    ns pointers {
        // NOTE: must be placed just after the startup, so that the read_ptr_byte_table will be in address 256.
        //
        // Space Complexity: w/2+261
        //   Initializes the global opcodes and pointer-copies required for the pointers macros.
        //   Initializes the read-byte-handling table and the result/return variables to the read-byte table.
        //
        // @output-param read_byte:  hex[:2] variable. You want to zero it before jumping into ptr_jump.
        //                           After jumping into ptr_jump, it's xored with the read byte.
        // @output_param ret_after_read_byte:  The return address. Jumps to it after finishing reading a byte.
        //
        // @output-param to_flip:  address of opcode that holds a flipping address in its first word. jumping into it will flip wanted bit.
        // @output-param to_flip_var:  the hex-vector (pointer) that also holds the flipping address.
        // @output-param to_jump:  address of opcode that holds a jumping address in its second word. jumping into it will jump to the wanted address.
        // @output-param to_jump_var:  the hex-vector (pointer) that also holds the jumping address.
        def ptr_init @ read_ptr_byte_table > to_flip, to_jump, to_flip_var, to_jump_var, \
                                             read_byte, ret_after_read_byte {
            pad 256
          // Time Complexity: 4/8 (when jumping to hex.pointers.to_jump, until finished)
          //                      (4 is for reading from an hex memory, 8 is for byte memory).
          read_ptr_byte_table:
            rep(256, d) stl.fj \
                d==0?0: (.read_byte+dbit+(#d)-1), \
                (d==((1<<(#d))>>1)) ? .ret_after_read_byte : read_ptr_byte_table+(d^((1<<(#d))>>1))*dw

          read_byte:
            hex.vec 2
          ret_after_read_byte:
            ;0

          to_flip:
            0;0
          to_jump:
            ;0

          to_flip_var:
            hex.vec w/4, 0
          to_jump_var:
            hex.vec w/4, 0
        }

        //  Time Complexity: w(0.5@+2)
        // Space Complexity: w(0.5@+14)
        //   Sets both to_jump and to_jump_var to point to the given pointer.
        //   (  to_jump{_var} = ptr  )
        // ptr is a hex[:w/4] that holds an address.
        def set_jump_pointer ptr < .to_jump, .to_jump_var {
            ..address_and_variable_xor w/4, .to_jump+w, .to_jump_var, .to_jump_var
            ..address_and_variable_xor w/4, .to_jump+w, .to_jump_var, ptr
        }

        //  Time Complexity: w(0.5@+2)
        // Space Complexity: w(0.5@+14)
        //   Sets both to_flip and to_flip_var to point to the given pointer.
        //   (  to_flip{_var} = ptr  )
        // ptr is a hex[:w/4] that holds an address.
        def set_flip_pointer ptr < .to_flip, .to_flip_var {
            ..address_and_variable_xor w/4, .to_flip, .to_flip_var, .to_flip_var
            ..address_and_variable_xor w/4, .to_flip, .to_flip_var, ptr
        }

        //  Time Complexity: w(0.75@+5)
        // Space Complexity: w(0.75@+29)
        //   Sets both to_flip and to_flip_var, and to_jump and to_jump_var to point to the given pointer.
        //   (  to_flip{_var} = ptr  )
        //   (  to_jump{_var} = ptr  )
        // ptr is a hex[:w/4] that holds an address.
        def set_flip_and_jump_pointers ptr < .to_flip, .to_flip_var, .to_jump, .to_jump_var {
            ..address_and_variable_xor w/4, .to_flip, .to_flip_var, .to_flip_var
            ..address_and_variable_xor w/4, .to_jump+w, .to_jump_var, .to_jump_var
            ..address_and_variable_double_xor w/4, .to_flip, .to_flip_var, .to_jump+w, .to_jump_var, ptr
        }

        // Space Complexity: n+w/4 + 330
        //   Initializes a stack of size n (maximal capacity of n hexes / return-addresses).
        // n is the size of the stack.
        // @output-param sp: the stack pointer. sp always points to the last pushed value (at start - to stack[-1])
        // @output-param stack: the global stack.
        def stack_init n @ stack_error_handler > sp, stack {
          sp:
            hex.vec w/4, .stack

            pad w
          stack:
            hex.hex stack_error_handler
            hex.vec n, 0

          stack_error_handler:
            stl.output "\n\nERROR: You returned on an empty stack.\n"
            ;0      // (would fail, so the stack trace would be printed).
        }
    }
}


ns hex {
    //  Time Complexity: w(0.5@+2)
    // Space Complexity: w(0.5@+14)
        //   like:  ;*ptr
    //   Jump to the address the pointer points to.
    // ptr is a hex[:w/4] that holds an address.
    def ptr_jump ptr < hex.pointers.to_jump {
        .pointers.set_jump_pointer ptr
        ;hex.pointers.to_jump
    }
}



// ---------- Flip:


ns hex {
    //  Time Complexity: w(0.5@+2)  + @
    // Space Complexity: w(0.5@+14) + @
    //   like:  *ptr;
    //   Flip the address the pointer points to.
    // ptr is a hex[:w/4] that holds an address.
    def ptr_flip ptr @ cleanup < hex.pointers.to_flip {
        wflip hex.pointers.to_flip+w, cleanup

        .pointers.set_flip_pointer ptr
        ;hex.pointers.to_flip

        pad 4
      cleanup:
        wflip hex.pointers.to_flip+w, cleanup
    }


    //  Time Complexity: w(0.5@+2)  + @+6
    // Space Complexity: w(0.5@+14) + @+6
    // The stl.comp_flip_if executes in ~##w, which should be much less than @/2 operations.
    //   like:  (*ptr)+dbit;
    //   Flip the address dbit-ahead of what the pointer points to.
    // ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def ptr_flip_dbit ptr < .pointers.to_flip {
        wflip .pointers.to_flip, dbit
        .ptr_flip ptr
        wflip .pointers.to_flip, dbit
    }


    //  Time Complexity: w(0.5@+2)  + 5@+12
    // Space Complexity: w(0.5@+14) + 5@+76
    //   like:  hex.xor *ptr, hex
    // ptr is a hex[:w/4] that holds an address, which we assume is an hex-variable, which is dw-aligned.
    def xor_hex_to_ptr ptr, hex {
        .pointers.set_flip_pointer ptr
        .pointers.xor_hex_to_flip_ptr hex
    }

    //  Time Complexity: w(0.5@+2)  + 5@+12
    // Space Complexity: w(0.5@+14) + 5@+76
    //   like:  hex.xor *ptr[:n], hex[:n]
    // ptr is a hex[:w/4] that holds an address, which we assume is an hex-variable, which is dw-aligned.
    def xor_hex_to_ptr n, ptr, hex {
        rep(n, i) .pointers.xor_hex_to_ptr_and_inc ptr, hex + i*dw
        .ptr_sub ptr, n
    }

    ns pointers {
        //  Time Complexity: w(0.5@+2)  + 5@+12
        // Space Complexity: w(0.5@+14) + 5@+76
        //   like:  hex.xor *ptr, hex
        //          ptr += dw
        // ptr is a hex[:w/4] that holds an address, which we assume is an hex-variable, which is dw-aligned.
        def xor_hex_to_ptr_and_inc ptr, hex {
            ..xor_hex_to_ptr ptr, hex
            ..ptr_inc ptr
        }

        //  Time Complexity: 5@+12
        // Space Complexity: 5@+76
        //   xors (the parameter hex) the hex pointed by the memory-word hex.pointers.to_flip.
        //   use after:  .pointers.set_flip_pointer ptr
        //   does:       .xor *ptr, hex    (as it uses the address in to_flip)
        // It assumes that the value in the memory-word to_flip is a dw-aligned address to an hex-variable.
        def xor_hex_to_flip_ptr hex @ prepare_flip_bit0, prepare_flip_bit1, prepare_flip_bit2, prepare_flip_bit3, \
                after_flip_bit0, after_flip_bit1, after_flip_bit2, after_flip_bit3,  cleanup  < hex.pointers.to_flip {
            wflip hex.pointers.to_flip+w, after_flip_bit0, prepare_flip_bit0

          prepare_flip_bit0:
            wflip hex.pointers.to_flip, dbit+0
            hex.if_flags hex, 0xAAAA, after_flip_bit0, hex.pointers.to_flip
          prepare_flip_bit1:
            wflip hex.pointers.to_flip, (dbit+0)^(dbit+1)
            hex.if_flags hex, 0xCCCC, after_flip_bit1, hex.pointers.to_flip
          prepare_flip_bit3:
            wflip hex.pointers.to_flip, (dbit+1)^(dbit+3)
            hex.if_flags hex, 0xFF00, after_flip_bit3, hex.pointers.to_flip
          prepare_flip_bit2:
            wflip hex.pointers.to_flip, (dbit+3)^(dbit+2)
            hex.if_flags hex, 0xF0F0, after_flip_bit2, hex.pointers.to_flip

            pad 4
          after_flip_bit0:
            hex.pointers.to_flip+dbit+0;prepare_flip_bit1
          after_flip_bit1:
            hex.pointers.to_flip+dbit+1;prepare_flip_bit3
          after_flip_bit2:
            wflip hex.pointers.to_flip, dbit+2, cleanup
          after_flip_bit3:
            hex.pointers.to_flip+dbit+0;prepare_flip_bit2

          cleanup:
            wflip hex.pointers.to_flip+w, after_flip_bit2
        }
    }

    //  Time Complexity: w(1.5@+5)
    // Space Complexity: w(1.5@+17)
    //   like:  wflip *ptr, value
    // ptr is a hex[:w/4] that holds an address, which we assume is w-aligned.
    def ptr_wflip ptr, value {
        .pointers.set_flip_pointer ptr
        rep(w, i) .pointers.advance_by_one_and_flip__ptr_wflip (#(i^((i+1)%w))), (value>>i)&1
    }
    ns pointers {
        // Advances *to_flip by 1 (which takes n flips, from bit0 to bit1, bit2,...).
        // If do_flip (value) isn't 0 - than make a flip, like:  to_flip;advance.
        def advance_by_one_and_flip__ptr_wflip n, do_flip @ cleanup, advance < hex.pointers.to_flip {
            stl.comp_if0 do_flip, advance
            wflip hex.pointers.to_flip+w, cleanup, hex.pointers.to_flip
          cleanup:
            wflip hex.pointers.to_flip+w, cleanup, advance

            pad 4
          advance:
            rep(n, i) bit.exact_not hex.pointers.to_flip+i
        }
    }

    //  Time Complexity: w(1.5@+5)
    // Space Complexity: w(1.5@+17)
    //   like:  wflip (*ptr)+w, value
    // ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def ptr_wflip_2nd_word ptr, value {
        ptr+dbit + ((#w-1)/4)*dw + (#w-1)%4;
        hex.ptr_wflip ptr, value
        ptr+dbit + ((#w-1)/4)*dw + (#w-1)%4;
    }
}



// ---------- Xor


ns hex {
    //  Time Complexity: w(0.75@+ 5) + 6@+13
    // Space Complexity: w(0.75@+29) + 6@+36
    //   like:  dst ^= *ptr
    // dst is a hex. ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def xor_hex_from_ptr dst, ptr < hex.pointers.read_byte {
        .pointers.set_flip_and_jump_pointers ptr
        .pointers.read_byte_from_inners_ptrs
        .xor dst, hex.pointers.read_byte
    }

    //  Time Complexity: w(0.75@+ 5) + 7@+13
    // Space Complexity: w(0.75@+29) + 7@+48
    //   like:  dst[:2] ^= *ptr
    // dst is a hex[2:]. ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
    def xor_byte_from_ptr dst, ptr < hex.pointers.read_byte {
        .pointers.set_flip_and_jump_pointers ptr
        .pointers.read_byte_from_inners_ptrs
        .xor 2, dst, hex.pointers.read_byte
    }

    ns pointers {
        //  Time Complexity: 5@+13
        // Space Complexity: 5@+24
        //   use after:  hex.pointers.set_flip_and_jump_pointers ptr
        //   does:       hex.pointers.read_byte[:2] = *ptr
        //
        // ptr is a hex[:w/4] that holds an address, which we assume is dw-aligned.
        def read_byte_from_inners_ptrs @ read_ptr_and_flip_back, cleanup \
                < hex.pointers.ret_after_read_byte, hex.pointers.read_byte, hex.pointers.to_jump, hex.pointers.to_flip {
            // 1.  setup:
            //       zero read_byte.
            //       to_flip   = ptr + dbit+8.
            //       to_jump+w = ptr.
            hex.zero 2, hex.pointers.read_byte
            wflip hex.pointers.to_flip, dbit+8

            // 2.  *(ptr+w)^=256, so that now *(ptr+w) == 256 + original_value.
            wflip hex.pointers.to_flip+w, read_ptr_and_flip_back, hex.pointers.to_flip

            pad 4
          read_ptr_and_flip_back:
            // 3.  Jump to *(ptr+w). It will xor the pointed original_value byte into hex.pointers.read_byte.
            // 4.  Then jump to hex.pointers.to_flip to make *(ptr+w)==original_value back again.
            // 5.  Then return to cleanup.
            wflip hex.pointers.to_flip+w, read_ptr_and_flip_back^cleanup
            wflip hex.pointers.ret_after_read_byte+w, hex.pointers.to_flip, hex.pointers.to_jump

          cleanup:
            // 6.  to_flip = ptr, clean jump-back addresses.
            wflip hex.pointers.ret_after_read_byte+w, hex.pointers.to_flip
            wflip hex.pointers.to_flip, dbit+8
            wflip hex.pointers.to_flip+w, cleanup
        }
    }
}



// Read & Write memory.
// TODO document


ns hex {
    // like:  dst = *ptr
    def read_hex dst, ptr {
        .zero dst
        .xor_hex_from_ptr dst, ptr
    }

    // like:  *ptr = src
    def write_hex ptr, src < hex.pointers.read_byte {
        .pointers.set_flip_and_jump_pointers ptr
        .pointers.read_byte_from_inners_ptrs
        .xor hex.pointers.read_byte, src
        .pointers.xor_hex_to_flip_ptr hex.pointers.read_byte
    }

    // like:  dst[:2] = *ptr
    def read_byte dst, ptr {
        .zero 2, dst
        .xor_byte_from_ptr dst, ptr
    }

    // like:  *ptr = 0
    def zero_ptr ptr < hex.pointers.read_byte {
        .pointers.set_flip_and_jump_pointers ptr
        .pointers.read_byte_from_inners_ptrs
        .pointers.xor_hex_to_flip_ptr hex.pointers.read_byte    // TODO make xor_byte_to_flip_ptr
    }

//    // like:  *ptr = src[:2]
//    def write_byte ptr, src {
//        .zero 2, dst
//        .xor_byte_from_ptr dst, ptr
//    }
}
