// ---------- Conditional Jump


ns hex {
    //  Time Complexity: @-1
    // Space Complexity: @+15
    //
    def if_flags hex, flags, l0, l1 @ switch, clean, return, finish {
        wflip hex+w, switch, hex

        pad 16
      switch:
        rep(16, i) fj    (flags>>i)&1 ? return+dbit+0 : 0,    clean

      clean:
        wflip hex+w, switch
      return: ;finish
        pad 2
      finish:
                     ; l0
        return+dbit+0; l1
    }

    //  Time Complexity: @-1
    // Space Complexity: @+15
    def if hex, l0, l1 {
        .if_flags hex, 0xfffe, l0, l1
    }
    def if0 hex, l0 @ l1 {
        .if hex, l0, l1
      l1:
    }
    def if1 hex, l1 @ l0 {
        .if hex, l0, l1
      l0:
    }

    //  Time Complexity: n(phi-1)
    // Space Complexity: n(phi+15)
    def if n, hex, l0, l1 {
        rep(n-1, i) .if1 hex+i*dw, l1
        .if hex+(n-1)*dw, l0, l1
    }
    def if0 n, hex, l0 @ l1 {
        .if n, hex, l0, l1
      l1:
    }
    def if1 n, hex, l1 @ l0 {
        .if n, hex, l0, l1
      l0:
    }


    //  Time Complexity: phi-1
    // Space Complexity: phi+15
    def sign n, x, neg, zpos {
        .if_flags x+(n-1)*dw, 0xff00, zpos, neg
    }


    //  Time Complexity: 3phi+12
    // Space Complexity: 3phi+51
    def cmp a, b, lt, eq, gt @ ret, _eq, _gt, real_ret, __lt, __eq, __gt, second_xor < .cmp.dst, ._.ret {
        .xor .cmp.dst, a    // 1
        ;second_xor


        pad 4
      ret:          // 4
        wflip ._.ret+w, ret, real_ret   // 5
        ._.ret+dbit  ;_eq
        ._.ret+dbit+1;_gt

      _eq:  real_ret+dbit  ;ret     // (4.5)
      _gt:  real_ret+dbit+1;ret

      real_ret:                     // 6
        ;__lt

        pad 4
      __lt:                 ;lt     // 7 (and last)
      __eq:  real_ret+dbit  ;eq
      __gt:  real_ret+dbit+1;gt


      second_xor:
        .xor .cmp.dst+4, b              // 2
        wflip ._.ret+w, ret, .cmp.dst   // 3
    }

    def cmp n, a, b, lt, eq, gt {
        rep(n-1, i) .cmp.cmp_eq_next a+(n-1-i)*dw, b+(n-1-i)*dw, lt, gt
        .cmp a, b, lt, eq, gt
    }

    ns cmp {
        def cmp_eq_next a, b, lt, gt @ eq {
            ..cmp a, b, lt, eq, gt
          eq:
        }

        // Space Complexity: 500
        def init @ switch, clean_table_entry, end < .._.ret > dst {
            ;end
          dst: ;.switch

            pad 256
          switch:
            // The next line is the compare flipping-table.
            // The [src<<4 | dst] entry flips bits in hex._.ret:
            //   if dst  > src:     flips dbit+1
            //   if dst == src:     flips dbit+0
            //   if dst  < src:     no flips
            // Upon entering here, .dst was xored with the correct table-entry, and was jumped into.
            rep(256, d) fj    ((d&0xf) > (d>>4)) ? .._.ret+dbit+1 : (((d&0xf) == (d>>4)) ? .._.ret+dbit : 0),    clean_table_entry+d*dw

          clean_table_entry:
            // xors back the table-entry from .dst
            .._.clean_table_entry__table .dst
          end:
        }
    }
}


ns hex {
    def init {
        ._.init
    }

    ns _ {
        // Space Complexity: 6700
        def init @ end > ret, res {
            ;end
          ret: ;0
          res: hex
          ..cmp.init    // 1600
          ..add.init    // 1800
          ..sub.init    //  500
          ..or.init     //  600
          ..and.init    //  600
          ..mul.init    // 1600
          end:
        }

        // @Assumes: n must be a power of 2, and it must be (1<<n)-padded.
        // A table. When jumping to entry d - it xors d into dst, and jumps to ret.
        def clean_table_entry__table n, dst, ret @ clean {
          clean:
            rep(n, d) fj    d==0?0: (dst+dbit+(#d)-1),    (d==((1<<(#d))>>1)) ? ret : clean+(d^((1<<(#d))>>1))*dw
        }

        // Space Complexity: 256
        def clean_table_entry__table dst < .ret {
            .clean_table_entry__table 256, dst, .ret
        }

        // The macro assumes that jumper_to_table is a fj-op that jumps to a 256-padded table.
        //   This macro is used as a jumper to a table that sets hex._.res to some (calc(dst, src) ^ dst), and jumps back.
        //
        //  Time Complexity: 4@+4
        // Space Complexity: 4@+52
        //
        // It jumps to the table, at entry (src<<4 | dst).
        // At last, it xors the value of hex._.res into dst.
        def jump_to_table_entry dst, src, jumper_to_table @ return < .ret, .res {
            ..xor jumper_to_table  , dst
            ..xor jumper_to_table+4, src
            wflip .ret+w, return, jumper_to_table
          return:
            wflip .ret+w ,return
            ..xor_zero dst, .res
        }
    }
}




// ---------- IO


ns hex {
    def output hex @ switch, print_0, print_2, print_4, print_6, print_8, print_a, print_c, print_e, end < IO {
        wflip hex+w, switch, hex
        pad 16
      switch:
        IO+0;print_0    //  0
        IO+1;print_0    //  1
        IO+0;print_2    //  2
        IO+1;print_2    //  3
        IO+0;print_4    //  4
        IO+1;print_4    //  5
        IO+0;print_6    //  6
        IO+1;print_6    //  7
        IO+0;print_8    //  8
        IO+1;print_8    //  9
        IO+0;print_a    //  4
        IO+1;print_a    //  5
        IO+0;print_c    //  6
        IO+1;print_c    //  7
        IO+0;print_e    //  8
        IO+1;print_e    //  9


      print_0:
        IO+0;
        IO+0;
        IO+0;end
      print_2:
        IO+1;print_0+1*dw
      print_4:
        IO+0;
        IO+1;print_0+2*dw
      print_6:
        IO+1;print_4+1*dw
      print_8:
        IO+0;
        IO+0;
        IO+1;end
      print_a:
        IO+1;print_8+1*dw
      print_c:
        IO+0;
        IO+1;print_8+2*dw
      print_e:
        IO+1;print_c+1*dw

      end:
        wflip hex+w, switch
    }


    def print x {
        .output x
        .output x+dw
    }

    def print n, x {
        rep(n, i) .print x+2*i*dw
    }


    //  Time Complexity: phi+4
    // Space Complexity: phi+51  phi-4+15+16+24
    def print_as_digit hex, big_flag @ switch, print_0, print_2, print_4, print_6, print_8, print_a, print_b, print_d, print_f, end < IO {
        wflip hex+w, switch, hex
        pad 16
      switch:
        IO+0;print_0    //  0
        IO+1;print_0    //  1
        IO+0;print_2    //  2
        IO+1;print_2    //  3
        IO+0;print_4    //  4
        IO+1;print_4    //  5
        IO+0;print_6    //  6
        IO+1;print_6    //  7
        IO+0;print_8    //  8
        IO+1;print_8    //  9

        IO+1;print_a    //  a
        IO+0;print_b    //  b
        IO+1;print_b    //  c
        IO+0;print_d    //  d
        IO+1;print_d    //  e
        IO+0;print_f    //  f

      print_0:
        IO+0;
        IO+0;
        IO+0;
        IO+1;
        IO+1;
        IO+0;
        IO+0;end
      print_2:
        IO+1;print_0+1*dw
      print_4:
        IO+0;
        IO+1;print_0+2*dw
      print_6:
        IO+1;print_4+1*dw
      print_8:
        IO+0;
        IO+0;
        IO+1;print_0+3*dw
      print_a:
        IO+0;
        IO+0;
        IO+0;
        IO+0;
        IO+(big_flag ? 0 : 1);
        IO+1;print_0+6*dw
      print_b:
        IO+1;print_a+1*dw
      print_d:
        IO+0;
        IO+1;print_a+2*dw
      print_f:
        IO+1;print_d+1*dw

      end:
        wflip hex+w, switch
    }

    //  Time Complexity: phi+4
    // Space Complexity: phi+42
    def print_as_digit n, x, big_flag {
        rep (n, i) .print_as_digit x+(n-1-i)*dw, big_flag
    }

    //  Time Complexity: n(2phi+8)
    // Space Complexity: n(3.5phi+72)
    def print_uint n, x, x_prefix, big_flag @ after_prefix, printed_something, end {
        bit.zero printed_something
        comp_if0 x_prefix, after_prefix
        output "0x"

      after_prefix:
        rep(n, i) .print_uint.print_digit x+(n-1-i)*dw, printed_something, big_flag
        bit.if1 printed_something, end
        output '0'
        ;end

      printed_something: bit
      end:
    }
    ns print_uint {
        //  Time Complexity: 2phi+8 (once: 3phi+9)
        // Space Complexity: 3.5phi+72
        def print_digit hex, printed_something, big_flag @ print, end {
            bit.if1 printed_something, print
            ..if0 hex, end
            bit.not printed_something
          print:
            ..print_as_digit hex, big_flag
          end:
        }
    }

    //  Time Complexity: n(2phi+16)
    // Space Complexity: n(6.5phi+126)
    def print_int n, x, x_prefix, big_flag @ do_neg, print, neg, end {
        bit.zero neg
        .if_flags x+(n-1)*dw, 0xff00, print, do_neg
      do_neg:
        bit.not neg
        .neg n, x
        output '-'
      print:
        .print_uint n, x, x_prefix, big_flag
        bit.if0 neg, end
        .neg n, x
        ;end

      neg: bit
      end:
    }

    //  Time Complexity: 2phi+7
    // Space Complexity: 2phi+39
    def input_hex hex @ flip0, flip1, flip2, flip3, end < IO {
        .zero hex
        wflip IO+w, flip0, IO

        pad 8
      flip0:
        IO+dbit+1;IO
        hex+dbit+0;flip0
      flip1:
        IO+dbit+2;IO
        hex+dbit+1;flip1
      flip3:
        wflip IO+w, flip3, end
        hex+dbit+3;flip3
      flip2:
        IO+dbit+1;IO
        hex+dbit+2;flip2
      end:
    }

    //  Time Complexity: 4phi+14
    // Space Complexity: 4phi+70
    def input x {
        .input_hex x
        .input_hex x+dw
    }

    //  Time Complexity: n(4phi+14)
    // Space Complexity: n(4phi+70)
    def input n, x {
        rep(n, i) .input x+2*i*dw
    }


    //  Time Complexity: 6phi+14
    // Space Complexity: 9.5phi+168
    def input_as_hex hex, error @ try_dec, do_dec, do_hex, switch, finish_hex, upper, end {
        .input_hex hex
        .input_hex upper
        .if_flags upper, (1<<4)|(1<<6), try_dec, do_hex
      try_dec:
        .if_flags upper, (1<<3), error, do_dec

      do_dec:
        .if_flags hex, (1<<10)-1, error, end

      do_hex:
        wflip hex+w, switch, hex

      finish_hex:
        hex+dbit+3;
        wflip hex+w, switch, end

        pad 16
      switch:
        wflip hex+w, switch, error  //  0
        hex+dbit+1;switch+2*dw      //  1
        hex+dbit+0;finish_hex       //  2
        hex+dbit+2;switch+1*dw      //  3
        hex+dbit+0;finish_hex       //  4
        hex+dbit+1;switch+2*dw      //  5
        hex+dbit+0;finish_hex       //  6
        ;switch                     //  7
        ;switch
        ;switch
        ;switch
        ;switch
        ;switch
        ;switch
        ;switch
        ;switch

      upper: hex
      end:
    }
}
