// TODO read 4-bit values (good for bit/hex/dec) values from pointers.


// ---------- Init


ns stl {
    // Comp
    def ptr_init {
        bit.pointers.ptr_init
        hex.pointers.ptr_init
    }

    // Space Complexity: n+w
    //   Initializes a stack of size n (maximal capacity of n bits / hexs / return-addresses).
    // n is the size of the stack.
    def stack_init n {
        hex.pointers.stack_init n
    }
}



// ---------- Functions


ns stl {
        // Complexity: w(5phi+21)
        // the pop_ret_address is counted for the future return
    def call address @ return_label {
        hex.push_ret_address return_label
        ;address

        pad 2
      return_label:
        hex.pop_ret_address return_label
    }


    // Complexity: w(7phi+29)
        // the last-call's pop_ret_address is counted for this return
    def return < hex.pointers.sp {
        hex.ptr_jump hex.pointers.sp
    }


    //  Time Complexity: n(2@)
    // Space Complexity: n(2@+24)
    // (Unsafe if dst is hex.pointers.sp).
    //   dst[:w/4] = sp
    def get_sp dst < hex.pointers.sp {
        hex.mov w/4, dst, hex.pointers.sp
    }
}



// ---------- Fast Call


ns stl {
    // Complexity: @-1
    def fcall label, ret_reg @ ret {
        wflip ret_reg+w, ret, label
        pad 2
      ret:
        wflip ret_reg+w, ret
    }

    // Complexity: 1
    def fret ret_reg {
        ;ret_reg
    }
}
