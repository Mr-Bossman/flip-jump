// Every line is (a bit) bananas!
// Implementation of single bit-variables operations

// should be assembled with an (exactly one) libXX.fjm file
// This file is independent of the bit-width, and uses the consts defined at libXX.fjm

// Everything after // is ignored, everything before first : is ignored too, and every whitespace is ignored (besides new line)
// An opcode is:  F;L  F  ;L  or just  ;  (no F => F=temp;  no L => L=next)


// TODO - implement 3 TODOs down below (then more-bit-versions in veclib.fjm), and then implement pointer dereference (read and write)



// ---------- Input / Output:




// ---------- Memory Variables:


.def bit0
    ;0
.end

.def bit1
    ;dw
.end



// ---------- Memory Manipulation:


.def flip_if0 src
    .__flip_if0 src label$
.end
.def __flip_if0 src cleaner_label
    ..flip_by flip_start_return_address cleaner_label

    ;src
  (cleaner_label)
    ..flip_by flip_start_return_address cleaner_label
.end


.def fix_flip dst
    .__fix_flip dst label$
.end
.def __fix_flip dst cleaner_label
    ..flip_by_dbit flip_back_dst dst
    ..flip_by flip_back_return_address cleaner_label

    ;flip_back
  (cleaner_label)
    ..flip_by_dbit flip_back_dst dst
    ..flip_by flip_back_return_address cleaner_label
.end


.def mov dst src    // b := a    O(8w, should be much less)
    .flip_if0 src
    .flip_if0 dst
    .fix_flip dst
.end



// ---------- Conditional Jump


.def test x l0 l1
    .__test x l0 l1 label$ label$
.end
.def __test x l0 l1 test_bit test_jump_label
    ..flip_by test_bit[w] test_jump_label
    .mov test_bit x
    ..flip_by test_bit[w] test_jump_label
  (test_bit)
    ;test_jump_label
    ..pad 2
  (test_jump_label)
    ;l0
    test_bit[dbit];l1
.end


// ---------- Logical Operators:


.def or dst src
    .__or dst src label$ label$
.end
.def __or dst src one_label cont_label
    .test src cont_label one_label
  (one_label)
    .mov dst one
  (cont_label)
.end


.def and dst src
    .__and dst src label$ label$
.end
.def __and dst src zero_label cont_label
    .test src zero_label cont_label
  (zero_label)
    .mov dst zero
  (cont_label)
.end


.def not dst
    dst[dbit];
.end



// ---------- Arithmetical Jump
// carry is both input and output. full adder like


.def inc x
    .__inc_carry1 x label$
.end
.def __inc_carry1 x carry_label
    .inc x carry_label
    ;carry_label[dw]
  (carry_label)
    ;dw
.end
.def inc x carry
    .__inc x carry label$ label$ label$
.end
.def __inc x carry inc_carry_on inc_end inc_turn_carry_off
    .test carry inc_end inc_carry_on
  (inc_carry_on)
    .not x
    .test x inc_end inc_turn_carry_off
  (inc_turn_carry_off)
    .not carry
  (inc_end)
.end


.def dec x
    .not x
    .inc x
    .not x
.end


.def neg x
    .not x
    .inc x
.end


.def add dst src
    __add_carry0 dst src label$
.end
.def __add_carry0 dst src carry_label
    .add dst src carry_label
    ;carry_label[dw]
  (carry_label)
    ;0
.end
.def add_carry1 dst src
    __add_carry1 dst src label$
.end
.def __add_carry1 dst src carry_label
    .add dst src carry_label
    ;carry_label[dw]
  (carry_label)
    ;dw
.end
.def add dst src carry
    .inc dst src
    .inc dst carry
    .or  dst carry
.end


.def sub dst src
    .not src
    .add_carry1 dst src
    .not src
.end

